* toc                                                                  :TOC:
- [[#modern-js][modern js]]
  - [[#lecture-1][lecture 1]]
  - [[#lecture-2][lecture 2]]
  - [[#lecture-3][lecture 3]]

* modern js
** lecture 1
** lecture 2
*** variable declarations vs initializations
    - declare just declares the variable
      + =var foo;= declares foo
      + =undefined= by default
    - initialization gives the first variable to the variable
      + =var foo = "nice"=, foo is initialized to a string value


    - Scope: defines where functions and variables are accessible in your program
      + two types in JS
        1. Function: if a variable statement occurs inside a function declaration, the variables are
           defined with function-level scope in that function, otherwise...
        2. Global: variables are created as members of the *global object*, that is, they are given
           global scope, when they are not declared inside a function


    McGinnis kind of confuses me here because he states the implication of these scopes is
    contextual to the usage of =var=. That is, a variable declared with =var= in a function has Function
    level scope but a variable "declared without =var=" is created as a property on the global
    function. So is this also a result of the semantics of =var=? I guess? /shrug/

    
    #+CAPTION: basic example of var and function scope
    #+begin_src js
      // gets us an unformatted date string
      function getDate() {
          // date is only accessible here within function scope, no shit
          var date = new Date();
          return date;
      }
      // works just fine
      console.log(getDate());

      // will return reference error
      // console.log(date);

      // gets us a formatted date string
      function getDate() {
          var date = new Date();
          function formatDate() {
              // Function scope means inner functions have a lexical bind to `date`
              // date until re-defined.
              return date.toDateString().slice(4);
          }
          return formatDate();
      }

      // Pretty date string
      console.log(getDate());
    #+end_src

    #+CAPTION: more complicated example of scope
    #+begin_src js
      function discount_prices(prices, discount) {
          var discounted = [];
          for (var i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // we still have access to each variable in this function declaration.
          // javascript is... really good, actually
          console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }

      discount_prices([100, 200, 300], .5)
      // can't refer to the variables just printed out to console
      // directly, however...
      // console.log(final_price); // error
    #+end_src

*** hoisting
    *Hoisting*: when the Javascript interpreter evals your code, it moves all functions and variable
    declarations at the "top" of the current scope.


    I think this is kinda of what Haskell does more or less, as this:

    #+begin_src js
      console.log(foo); // output: undefined
      var foo;
    #+end_src
    
    ...before execution becomes this:
    
    #+begin_src js
      var foo;
      console.log(foo) // output: undefined
    #+end_src

    Taking the =discount_prices= example, it becomes the following:

    #+begin_src js
      function discount_prices(prices, discount) {
          var discounted;
          var i;
          var discount_prices;
          var final_price;
          var discounted = [];
          for (var i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // we still have access to each variable in this function declaration.
          // javascript is... really good, actually
          console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }
    #+end_src

**** hoisting and =var=

     The reason why =var= is a matter of concern with respect to function scope is that if a variable
     were to be declared without =var=, then the JS interpreter will continue looking "outwards" from
     the function scope until it reaches the global scope. When no such declaration is found, the JS
     interpreter will declare that variable as a property of the global scope. /Nice! Great language!/

     Don't actually do this!

*** =var= vs =let= vs =const=

    The main differences: between =var= and =let=:
    - =let=
      + block scoped, not function scoped
        * it is available within the set of statements between the ={}='s you declared it within
        * this is more like sane languages with sane scoping defaults
      + =ReferenceError= when accessing a variable before it's declared
    - =var=
      + function scoped
        * Available throughout the entire function it is declared within
      + =undefined= returned when accessing a variable before it's declared
        
    Recall the =i= counter variable from the last example. If you declare it with =let=, the console
    statement for it no longer works. =ReferenceError= will be returned. Similarly, if you were to try
    to console.log() a variable before it gets assigned a value, like =discounted=, it would also
    return a =ReferenceError= instead of =undefined= if it were declared with =var=.

    #+begin_src js
      function discount_prices(prices, discount) {
          // returns error if attempted:
          // console.log(discounted)
    
          // this still works, though, because discounted_price is decl with var
          console.log(discounted_price); // returns undefined
          let discounted = [];
          for (let i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // No longer will work, will throw error.
          // console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }

      discount_prices([100, 200, 300], .5)
    #+end_src

    The only real difference between =let= and =const= is that =const= assignments are immutable and you
    must declare the variable (i.e., you cannot initialize without a value). 

    #+begin_src js
      // Error!
      // const foo;
      const foo = "foo";
      // Error!
      // foo = "bar";
      let bar = "bar";
      bar = "foo";
      var buz = "buz";
      buz = "fizz";
    #+end_src

    =const='s immutability is not perfect, however:

    #+begin_src js
      const person = {
        name: 'Kim Kardashian'
      }

      person.name = 'Kim Kardashian West' // totally legal. 

      // person = {} // Error!
    #+end_src

    Reassigning the field is legal because the =const= declaration is on the object itself, not every
    field. Changing the value of the field is not taken as reassignment, whereas attempting to
    reassign =person= itself to ={}= is taken as illegal for that exact reason.

    *try to always use const.*

** lecture 3
*** dot notation and object literals

    to add something to a js object, *dot notation* works just fine. you can similarly access the
    fields using dot notation.

    #+begin_src js
      const user = {};
      user.name = 'elias'
      user.handle = 'don\'t have one because twitter deleted me for no reason';
      user.location = 'westport';

      const name = user.name;
      const local = user.location;
    #+end_src

    to add multiple fields at once, use javascript's *object literal notation*.

    #+begin_src js
      const user = {
          name: 'elias',
          handle: 'lol',
          location: 'westport',
      };

      const name = user.name;
    #+end_src
*** object destructuring
    *object destructuring* is effectively the opposite of object literal notation, i.e. "allows you to
    extract multiple properties from an object". introduced by ES2015. drastically reduces
    boilerplate.

    this:
    #+begin_src js
      const name = user.name;
      const handle = user.handle;
      const local = user.location;
      // ... and so on
    #+end_src

    becomes:
    #+begin_src js
      const { name, handle, local } = user;
    #+end_src

    Destructuring semantics /apply to functions/ as well:

    #+begin_src js
      function getUser() {
          return {
              name: 'elias',
              handle: 'lol',
              location: 'westport',
          }
      }

      const { name, handle, locale } = getUser();
    #+end_src

    can also use destructuring on arrays. presumably this is useful in combination with nested json
    structures? idk, not complaining.

    #+begin_src js
      const user = ['elias', 'lol', 'westport'];
      const [ name, handle, local ] = user;
    #+end_src

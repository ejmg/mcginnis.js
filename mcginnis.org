* toc                                                                :TOC_3:
- [[#modern-js][modern js]]
  - [[#lecture-1][lecture 1]]
  - [[#lecture-2][lecture 2]]
    - [[#variable-declarations-vs-initializations][variable declarations vs initializations]]
    - [[#hoisting][hoisting]]
    - [[#var-vs-let-vs-const][=var= vs =let= vs =const=]]
  - [[#lecture-3][lecture 3]]
    - [[#dot-notation-and-object-literals][dot notation and object literals]]
    - [[#object-destructuring][object destructuring]]
    - [[#advanced-features-of-destructuring][advanced features of destructuring]]
  - [[#lecture-4][lecture 4]]
    - [[#shorthand-properties][shorthand properties]]
    - [[#shorthand-method][shorthand method]]
  - [[#lecture-5][lecture 5]]
    - [[#computed-views][computed views]]
  - [[#lecture-6][lecture 6]]
    - [[#template-literals][template literals]]
  - [[#lecture-7][lecture 7]]

* modern js
** lecture 1
** lecture 2
*** variable declarations vs initializations
    - declare just declares the variable
      + =var foo;= declares foo
      + =undefined= by default
    - initialization gives the first variable to the variable
      + =var foo = "nice"=, foo is initialized to a string value


    - Scope: defines where functions and variables are accessible in your program
      + two types in JS
        1. Function: if a variable statement occurs inside a function declaration, the variables are
           defined with function-level scope in that function, otherwise...
        2. Global: variables are created as members of the *global object*, that is, they are given
           global scope, when they are not declared inside a function


    McGinnis kind of confuses me here because he states the implication of these scopes is
    contextual to the usage of =var=. That is, a variable declared with =var= in a function has Function
    level scope but a variable "declared without =var=" is created as a property on the global
    function. So is this also a result of the semantics of =var=? I guess? /shrug/

    
    #+CAPTION: basic example of var and function scope
    #+begin_src js
      // gets us an unformatted date string
      function getDate() {
          // date is only accessible here within function scope, no shit
          var date = new Date();
          return date;
      }
      // works just fine
      console.log(getDate());

      // will return reference error
      // console.log(date);

      // gets us a formatted date string
      function getDate() {
          var date = new Date();
          function formatDate() {
              // Function scope means inner functions have a lexical bind to `date`
              // date until re-defined.
              return date.toDateString().slice(4);
          }
          return formatDate();
      }

      // Pretty date string
      console.log(getDate());
    #+end_src

    #+CAPTION: more complicated example of scope
    #+begin_src js
      function discount_prices(prices, discount) {
          var discounted = [];
          for (var i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // we still have access to each variable in this function declaration.
          // javascript is... really good, actually
          console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }

      discount_prices([100, 200, 300], .5)
      // can't refer to the variables just printed out to console
      // directly, however...
      // console.log(final_price); // error
    #+end_src

*** hoisting
    *Hoisting*: when the Javascript interpreter evals your code, it moves all functions and variable
    declarations at the "top" of the current scope.


    I think this is kinda of what Haskell does more or less, as this:

    #+begin_src js
      console.log(foo); // output: undefined
      var foo;
    #+end_src
    
    ...before execution becomes this:
    
    #+begin_src js
      var foo;
      console.log(foo) // output: undefined
    #+end_src

    Taking the =discount_prices= example, it becomes the following:

    #+begin_src js
      function discount_prices(prices, discount) {
          var discounted;
          var i;
          var discount_prices;
          var final_price;
          var discounted = [];
          for (var i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // we still have access to each variable in this function declaration.
          // javascript is... really good, actually
          console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }
    #+end_src

**** hoisting and =var=

     The reason why =var= is a matter of concern with respect to function scope is that if a variable
     were to be declared without =var=, then the JS interpreter will continue looking "outwards" from
     the function scope until it reaches the global scope. When no such declaration is found, the JS
     interpreter will declare that variable as a property of the global scope. /Nice! Great language!/

     Don't actually do this!

*** =var= vs =let= vs =const=

    The main differences: between =var= and =let=:
    - =let=
      + block scoped, not function scoped
        * it is available within the set of statements between the ={}='s you declared it within
        * this is more like sane languages with sane scoping defaults
      + =ReferenceError= when accessing a variable before it's declared
    - =var=
      + function scoped
        * Available throughout the entire function it is declared within
      + =undefined= returned when accessing a variable before it's declared
        
    Recall the =i= counter variable from the last example. If you declare it with =let=, the console
    statement for it no longer works. =ReferenceError= will be returned. Similarly, if you were to try
    to console.log() a variable before it gets assigned a value, like =discounted=, it would also
    return a =ReferenceError= instead of =undefined= if it were declared with =var=.

    #+begin_src js
      function discount_prices(prices, discount) {
          // returns error if attempted:
          // console.log(discounted)
    
          // this still works, though, because discounted_price is decl with var
          console.log(discounted_price); // returns undefined
          let discounted = [];
          for (let i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // No longer will work, will throw error.
          // console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }

      discount_prices([100, 200, 300], .5)
    #+end_src

    The only real difference between =let= and =const= is that =const= assignments are immutable and you
    must declare the variable (i.e., you cannot initialize without a value). 

    #+begin_src js
      // Error!
      // const foo;
      const foo = "foo";
      // Error!
      // foo = "bar";
      let bar = "bar";
      bar = "foo";
      var buz = "buz";
      buz = "fizz";
    #+end_src

    =const='s immutability is not perfect, however:

    #+begin_src js
      const person = {
        name: 'Kim Kardashian'
      }

      person.name = 'Kim Kardashian West' // totally legal. 

      // person = {} // Error!
    #+end_src

    Reassigning the field is legal because the =const= declaration is on the object itself, not every
    field. Changing the value of the field is not taken as reassignment, whereas attempting to
    reassign =person= itself to ={}= is taken as illegal for that exact reason.

    *try to always use const.*

** lecture 3
*** dot notation and object literals

    to add something to a js object, *dot notation* works just fine. you can similarly access the
    fields using dot notation.

    #+begin_src js
      const user = {};
      user.name = 'elias'
      user.handle = 'don\'t have one because twitter deleted me for no reason';
      user.location = 'westport';

      const name = user.name;
      const local = user.location;
    #+end_src

    to add multiple fields at once, use javascript's *object literal notation*.

    #+begin_src js
      const user = {
          name: 'elias',
          handle: 'lol',
          location: 'westport',
      };

      const name = user.name;
    #+end_src
*** object destructuring
    *object destructuring* is effectively the opposite of object literal notation, i.e. "allows you to
    extract multiple properties from an object". introduced by ES2015. drastically reduces
    boilerplate.

    this:
    #+begin_src js
      const name = user.name;
      const handle = user.handle;
      const local = user.location;
      // ... and so on
    #+end_src

    becomes:
    #+begin_src js
      const { name, handle, location } = user;
    #+end_src

    note that the variables destructuring the object *must have the same name* using plain
    destructuring, i.e. =local= won't be defined in this statement:
    #+begin_src js
      const { name, handle, local} = user;
    #+end_src

    Destructuring semantics /apply to functions/ as well:

    #+begin_src js
      function getUser() {
          return {
              name: 'elias',
              handle: 'lol',
              location: 'westport',
          }
      }

      const { name, handle, location } = getUser();
    #+end_src

    can also use destructuring on arrays. presumably this is useful in combination with nested json
    structures? idk, not complaining.

    #+begin_src js
      const user = ['elias', 'lol', 'westport'];
      const [ name, handle, local ] = user;
    #+end_src

*** advanced features of destructuring

    What if you want the variable name to be different than the field?

    #+begin_src js
      const user = {
          n: 'smalls',
          h: '@biggiesmols',
          l: 'westport',
      };
    #+end_src

    to destructure the following object with better identifier names, assign them on the right using
    syntax similar to object literal notation:

    #+begin_src js
      const {n: name, h: handle, l: location } = user;
    #+end_src

    looks useless? happens all the time. here's what the =Link= component for React Router Native
    looks like:

    #+begin_src js
      render () {
        // Note, component gets renamed to Component with capital C
        const { component: Component, to , replace, ...rest } = this.props
        return <Component {...rest} onPress={this.handlePress}/>
      }
    #+end_src

    
**** object destructuring on function arguments and params

     We have the following function for interacting with GitHub's api:
     #+begin_src js
       function fetchRepos (language, minStars, maxStars, createdBefore, createAfter) {
           // api logic
       }
     #+end_src

     two problems introduced by this function:
     1. need to remember order of arguments
     2. need to remember/know what each arg is for and how we pass it in, i.e. form, type

        
     one solution is just to yeet in what we know and make the rest nulls:

     #+begin_src js
       fetchRepos('JavaScript', 100, null, new Date('01.01.2017').getTime(), null);
     #+end_src

     ... /or we could use destructuring to solve these problems/.
     
     #+begin_src js
       fetchRepos({
           language: 'JavaScript',
           maxStars: null,
           createdAfter: null,
           createdBefore: new Date('01/01/2017').getTime(),
           minStars: 100,
       });
     #+end_src

     by using object destructuring, we remove the order of params as an issue. The arguments are
     passed in by name with reference to the param's field names.

     to solve the issue of argument types, we can use *default values* for all properties to ensure
     all are given something that will work (otherwise, we have no clue if a value like =null= will be
     accepted, work as intended). One ways to do this is by re-declaring the variables within the
     function body to accept either the passed value or, if =undefined=, instead pass a different value:

     #+begin_src js
       function fetchRepos ({ language, minStars, maxStars, createdBefore, createAfter }) {
         language = language || 'All';
         minStars = minStars || 0;
         maxStars = maxStars || '';
         createdBefore = createdBefore || '';
         createdAfter = createdAfter || '';
       }
     #+end_src

     This is kinda ugly, though. /Object destructuring allows default values, however/, which yields a
     much cleaner function signature:

     #+begin_src js
       function fetchRepos({ language='All', minStars=0, maxStars='', createdBefore='', createdAfter='' }) {
           // api logic
           console.log(language);
           console.log(minStars);
           console.log(maxStars);
           console.log(createdBefore);
           console.log(createdAfter);
       }
     #+end_src

     Now our api call becomes the much cleaner statement:
     #+begin_src js
       fetchRepos({
         language: 'JavaScript',
         createdBefore: new Date('01/01/2017').getTime(),
         minStars: 100,
       });
       // prints to console:
       // "JavaScript"
       // 100
       // 
       // 1483250400000
       // 
     #+end_src

**** array destructuring and function params

     Can do the same with arrays with respect to function params. Have the following function:
     #+begin_src js
       function getUserData (player) {
         // note that we wrap our function calls in an array here
         return Promise.all([
           getProfile(player),
           getRepos(player)
         ]).then(function (data) {
           // extract array vals
           const profile = data[0];
           const repos = data[1];

           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

     Side note: the above function uses *Promise*'s with calls to =getProfile= and =getRepos=, which are
     async functions. Once those promises /resolve/, we pass a function to =.then()=, which handles the
     results of the promise.

     inside of =.then()=, we declare a function that takes a param =data=, which will be an array that
     has indices. The first is the user's profile, the second is their repos. /Order matters here/
     because it's an array and because of the order of the calls we made to the functions returning
     promises.

     To take advantage of the array structure, we can destructure the values returned by our
     promises so don't need to extract them manually:

     #+begin_src js
       function getUserData (player) {
         return Promise.all([
           getProfile(player),
           getRepos(player)
         ]).then(function (data) {
           // we destructure the values of data here
           const [ profile, repos ] = data
           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

     One final improvement is, just like with objects, is to move the restructuring directly into
     the params of the function (passed to =.then()=) itself:
     
     #+begin_src js
       function getUserData (player) {
         return Promise.all([
           getProfile(player),
           getRepos(player)
           // yeet, clean code
         ]).then(([ profile, repos ]) => {
           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

** lecture 4
*** shorthand properties

    *shorthand property*: whenever you have a variable that matches the name of a property on an
    object, you can omit the property name when constructing an instance of that object.

    the following:
    #+begin_src js
      function formatMessage (name, id, avatar) {
          return {
              name: name,
              id: id,    
              avatar: avatar,    
              timestamp: Date.now()
          }
      }
    #+end_src

    can be shortened to:
    #+begin_src js
      function formatMessage (name, id, avatar) {
          return {
              name,    
              id,    
              avatar,    
              timestamp: Date.now()
          }
      }
    #+end_src
*** shorthand method
    *shorthand method names*: when a function is a property on an object, that makes it a *method*. As
     of ES6, when constructing an object that has a function as a field you can now omit the
     =function= keyword entirely.

     The following:
     #+begin_src js
       function formatMessage (name, id, avatar) {
           return {
               name,
               id,
               avatar,
               timestamp: Date.now(),
               save: function () {
                   // save message    
               }  
           }
       }
     #+end_src

     can become:
     #+begin_src js
       function formatMessage (name, id, avatar) {
           return {
               name,
               id,
               avatar,
               timestamp: Date.now(),
               // wow i saved like 8 whole keystrokes wow lol
               save () {
                   // save message    
               }  
           }
       }     
     #+end_src
** lecture 5
*** computed views
    *computed property names*: as of ES6, you can have expressions that get evaluated as properties on
    an object.

    Say you have a function that takes a (=key=, =value=) pair and returns an object that maps =key= as a
    property with =value= as its value:

    #+begin_src js
      function objectify (key, value) {
          let obj = {}
          obj[key] = value
          return obj
      }

      objectify('name', 'elias') // { name: 'elias' }
    #+end_src

    Now with computed property names you can do this:
    #+begin_src js
      function objectify (key, value) {
          return {
              [key]: value
          }
      }    
    #+end_src

    The =[]= are critical to the behavior of this feature. Note how the following function behaves:
    #+begin_src js
      function confusing_var_names(bar, bat) {
          return {
              [bar]: bat,
              is: 'forever'
          }
      }

      confusing_var_names('wu', 'tang') // returns { wu: 'tang', is: 'forever' }
    #+end_src
** lecture 6
*** template literals
    In the olden days, when you wanted to return a formatted strings with a bunch of variables
    injected into it, you had to do horrid shit like this:
    #+begin_src js
      function makeGreetingTemplate (name, email, id) {
          return '<div>' +
              '<h1>Hello, ' + name + '.</h1>' +
              '<p>We\'ve emailed you at ' + email + '. ' +
              'Your user id is "' + id + '".</p>' +
              '</div>'
      }
    #+end_src

    With *template literals*, instead of worrying about escaping all special characters and
    concatenating a bunch of strings together, you instead wrap the string with =``='s instead of =""='s
    or =''='s. Any expression you wish to inject into the template is surrounded by =${/* expr here */}=.

    Now look at the same function with template literals:

    #+begin_src js
      function makeGreetingTemplate (name, email, id) {
          return `
          <div>
            <h1>Hello, ${name}</h1>
            <p>
              We've email you at ${email}.
              Your user id is "${id}".
            </p>
          </div>
        `
      }
    #+end_src
** lecture 7


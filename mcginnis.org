* toc                                                                :TOC_3:
- [[#modern-js][modern js]]
  - [[#lecture-1][lecture 1]]
  - [[#lecture-2][lecture 2]]
    - [[#variable-declarations-vs-initializations][variable declarations vs initializations]]
    - [[#hoisting][hoisting]]
    - [[#var-vs-let-vs-const][â€‹=var= vs =let= vs =const=]]
  - [[#lecture-3][lecture 3]]
    - [[#dot-notation-and-object-literals][dot notation and object literals]]
    - [[#object-destructuring][object destructuring]]
    - [[#advanced-features-of-destructuring][advanced features of destructuring]]
  - [[#lecture-4][lecture 4]]
    - [[#shorthand-properties][shorthand properties]]
    - [[#shorthand-method][shorthand method]]
  - [[#lecture-5][lecture 5]]
    - [[#computed-views][computed views]]
  - [[#lecture-6][lecture 6]]
    - [[#template-literals][template literals]]
  - [[#lecture-7][lecture 7]]
    - [[#arrow-functions][arrow functions]]
    - [[#managing-this-with-arrow-functions][managing =this= with arrow functions]]
    - [[#nice-to-knows-about-arrow-functions]["nice to knows" about arrow functions]]
  - [[#lecture-8][lecture 8]]
    - [[#default-params][default params]]
    - [[#required-arguments]["required" arguments]]
  - [[#lecture-9][lecture 9]]
    - [[#compiling-vs-polyfills-with-babel][compiling vs Polyfills with Babel]]
  - [[#lecture-10][lecture 10]]
    - [[#callbacks][callbacks]]
    - [[#darkside-of-callbacks][darkside of callbacks]]
    - [[#promises][Promises]]
    - [[#chaining][chaining]]
    - [[#resolve][resolve]]
    - [[#improvements-to-chaining-and-resolve][improvements to chaining and resolve]]
    - [[#error-handling][error handling]]
  - [[#lecture-11][lecture 11]]
    - [[#objects][objects]]
    - [[#functional-instantiation][functional instantiation]]
    - [[#functional-instantiation-with-shared-methods][Functional Instantiation with Shared Methods]]
    - [[#objectcreate][Object.create]]
    - [[#functional-instatiation-with-shared-methods-and-objectcreate][Functional Instatiation with Shared Methods and Object.create]]
    - [[#prototypal-instantiation][Prototypal Instantiation]]
    - [[#psuedo-classical-instantiation][psuedo-classical instantiation]]
    - [[#classes][classes]]
    - [[#array-methods][array methods]]
    - [[#static-methods][static methods]]
    - [[#getting-the-prototype-of-an-object][getting the prototype of an object]]
    - [[#determining-if-a-property-lives-on-a-prototype][determining if a property lives on a prototype]]
    - [[#check-if-object-is-an-instance-of-class][check if object is an instance of class]]
    - [[#creating-new-agnostic-constructor-functions][creating new agnostic constructor functions]]
    - [[#recreating-the-objectcreate-method][recreating the =Object.create()= method]]
    - [[#arrow-functions-1][arrow functions]]
  - [[#lecture-12][lecture 12]]
    - [[#why-modules][why modules]]
    - [[#js-modules][js modules]]
    - [[#js-modules-from-the-ground-up][js modules from the ground up]]
    - [[#immediately-invoked-function-expressions-iife][Immediately Invoked Function Expressions (IIFE)]]
    - [[#module-exports][module exports]]
    - [[#defining-our-module-api][defining our module api]]
    - [[#module-bundlers][Module Bundlers]]
    - [[#es-modules][ES Modules]]
    - [[#tree-shaking][tree shaking]]
  - [[#lecture-13][lecture 13]]
    - [[#class-fields][Class Fields]]
    - [[#downsides-of-class-fields][downsides of class fields]]
    - [[#private-fields][private fields]]

* modern js
** lecture 1
** lecture 2
*** variable declarations vs initializations
    - declare just declares the variable
      + =var foo;= declares foo
      + =undefined= by default
    - initialization gives the first variable to the variable
      + =var foo = "nice"=, foo is initialized to a string value


    - Scope: defines where functions and variables are accessible in your program
      + two types in JS
        1. Function: if a variable statement occurs inside a function declaration, the variables are
           defined with function-level scope in that function, otherwise...
        2. Global: variables are created as members of the *global object*, that is, they are given
           global scope, when they are not declared inside a function


    McGinnis kind of confuses me here because he states the implication of these scopes is
    contextual to the usage of =var=. That is, a variable declared with =var= in a function has Function
    level scope but a variable "declared without =var=" is created as a property on the global
    function. So is this also a result of the semantics of =var=? I guess? /shrug/

    
    #+CAPTION: basic example of var and function scope
    #+begin_src js
      // gets us an unformatted date string
      function getDate() {
          // date is only accessible here within function scope, no shit
          var date = new Date();
          return date;
      }
      // works just fine
      console.log(getDate());

      // will return reference error
      // console.log(date);

      // gets us a formatted date string
      function getDate() {
          var date = new Date();
          function formatDate() {
              // Function scope means inner functions have a lexical bind to `date`
              // date until re-defined.
              return date.toDateString().slice(4);
          }
          return formatDate();
      }

      // Pretty date string
      console.log(getDate());
    #+end_src

    #+CAPTION: more complicated example of scope
    #+begin_src js
      function discount_prices(prices, discount) {
          var discounted = [];
          for (var i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // we still have access to each variable in this function declaration.
          // javascript is... really good, actually
          console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }

      discount_prices([100, 200, 300], .5)
      // can't refer to the variables just printed out to console
      // directly, however...
      // console.log(final_price); // error
    #+end_src

*** hoisting
    *Hoisting*: when the Javascript interpreter evals your code, it moves all functions and variable
    declarations at the "top" of the current scope.


    I think this is kinda of what Haskell does more or less, as this:

    #+begin_src js
      console.log(foo); // output: undefined
      var foo;
    #+end_src
    
    ...before execution becomes this:
    
    #+begin_src js
      var foo;
      console.log(foo) // output: undefined
    #+end_src

    Taking the =discount_prices= example, it becomes the following:

    #+begin_src js
      function discount_prices(prices, discount) {
          var discounted;
          var i;
          var discount_prices;
          var final_price;
          var discounted = [];
          for (var i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // we still have access to each variable in this function declaration.
          // javascript is... really good, actually
          console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }
    #+end_src

**** hoisting and =var=

     The reason why =var= is a matter of concern with respect to function scope is that if a variable
     were to be declared without =var=, then the JS interpreter will continue looking "outwards" from
     the function scope until it reaches the global scope. When no such declaration is found, the JS
     interpreter will declare that variable as a property of the global scope. /Nice! Great language!/

     Don't actually do this!

*** â€‹=var= vs =let= vs =const=

    The main differences: between =var= and =let=:
    - =let=
      + block scoped, not function scoped
        * it is available within the set of statements between the ={}='s you declared it within
        * this is more like sane languages with sane scoping defaults
      + =ReferenceError= when accessing a variable before it's declared
    - =var=
      + function scoped
        * Available throughout the entire function it is declared within
      + =undefined= returned when accessing a variable before it's declared
        
    Recall the =i= counter variable from the last example. If you declare it with =let=, the console
    statement for it no longer works. =ReferenceError= will be returned. Similarly, if you were to try
    to console.log() a variable before it gets assigned a value, like =discounted=, it would also
    return a =ReferenceError= instead of =undefined= if it were declared with =var=.

    #+begin_src js
      function discount_prices(prices, discount) {
          // returns error if attempted:
          // console.log(discounted)
    
          // this still works, though, because discounted_price is decl with var
          console.log(discounted_price); // returns undefined
          let discounted = [];
          for (let i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // No longer will work, will throw error.
          // console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }

      discount_prices([100, 200, 300], .5)
    #+end_src

    The only real difference between =let= and =const= is that =const= assignments are immutable and you
    must declare the variable (i.e., you cannot initialize without a value). 

    #+begin_src js
      // Error!
      // const foo;
      const foo = "foo";
      // Error!
      // foo = "bar";
      let bar = "bar";
      bar = "foo";
      var buz = "buz";
      buz = "fizz";
    #+end_src

    =const='s immutability is not perfect, however:

    #+begin_src js
      const person = {
        name: 'Kim Kardashian'
      }

      person.name = 'Kim Kardashian West' // totally legal. 

      // person = {} // Error!
    #+end_src

    Reassigning the field is legal because the =const= declaration is on the object itself, not every
    field. Changing the value of the field is not taken as reassignment, whereas attempting to
    reassign =person= itself to ={}= is taken as illegal for that exact reason.

    *try to always use const.*

** lecture 3
*** dot notation and object literals

    to add something to a js object, *dot notation* works just fine. you can similarly access the
    fields using dot notation.

    #+begin_src js
      const user = {};
      user.name = 'elias'
      user.handle = 'don\'t have one because twitter deleted me for no reason';
      user.location = 'westport';

      const name = user.name;
      const local = user.location;
    #+end_src

    to add multiple fields at once, use javascript's *object literal notation*.

    #+begin_src js
      const user = {
          name: 'elias',
          handle: 'lol',
          location: 'westport',
      };

      const name = user.name;
    #+end_src
*** object destructuring
    *object destructuring* is effectively the opposite of object literal notation, i.e. "allows you to
    extract multiple properties from an object". introduced by ES2015. drastically reduces
    boilerplate.

    this:
    #+begin_src js
      const name = user.name;
      const handle = user.handle;
      const local = user.location;
      // ... and so on
    #+end_src

    becomes:
    #+begin_src js
      const { name, handle, location } = user;
    #+end_src

    note that the variables destructuring the object *must have the same name* using plain
    destructuring, i.e. =local= won't be defined in this statement:
    #+begin_src js
      const { name, handle, local} = user;
    #+end_src

    Destructuring semantics /apply to functions/ as well:

    #+begin_src js
      function getUser() {
          return {
              name: 'elias',
              handle: 'lol',
              location: 'westport',
          }
      }

      const { name, handle, location } = getUser();
    #+end_src

    can also use destructuring on arrays. presumably this is useful in combination with nested json
    structures? idk, not complaining.

    #+begin_src js
      const user = ['elias', 'lol', 'westport'];
      const [ name, handle, local ] = user;
    #+end_src

*** advanced features of destructuring

    What if you want the variable name to be different than the field?

    #+begin_src js
      const user = {
          n: 'smalls',
          h: '@biggiesmols',
          l: 'westport',
      };
    #+end_src

    to destructure the following object with better identifier names, assign them on the right using
    syntax similar to object literal notation:

    #+begin_src js
      const {n: name, h: handle, l: location } = user;
    #+end_src

    looks useless? happens all the time. here's what the =Link= component for React Router Native
    looks like:

    #+begin_src js
      render () {
        // Note, component gets renamed to Component with capital C
        const { component: Component, to , replace, ...rest } = this.props
        return <Component {...rest} onPress={this.handlePress}/>
      }
    #+end_src

    
**** object destructuring on function arguments and params

     We have the following function for interacting with GitHub's api:
     #+begin_src js
       function fetchRepos (language, minStars, maxStars, createdBefore, createAfter) {
           // api logic
       }
     #+end_src

     two problems introduced by this function:
     1. need to remember order of arguments
     2. need to remember/know what each arg is for and how we pass it in, i.e. form, type

        
     one solution is just to yeet in what we know and make the rest nulls:

     #+begin_src js
       fetchRepos('JavaScript', 100, null, new Date('01.01.2017').getTime(), null);
     #+end_src

     ... /or we could use destructuring to solve these problems/.
     
     #+begin_src js
       fetchRepos({
           language: 'JavaScript',
           maxStars: null,
           createdAfter: null,
           createdBefore: new Date('01/01/2017').getTime(),
           minStars: 100,
       });
     #+end_src

     by using object destructuring, we remove the order of params as an issue. The arguments are
     passed in by name with reference to the param's field names.

     to solve the issue of argument types, we can use *default values* for all properties to ensure
     all are given something that will work (otherwise, we have no clue if a value like =null= will be
     accepted, work as intended). One ways to do this is by re-declaring the variables within the
     function body to accept either the passed value or, if =undefined=, instead pass a different value:

     #+begin_src js
       function fetchRepos ({ language, minStars, maxStars, createdBefore, createAfter }) {
         language = language || 'All';
         minStars = minStars || 0;
         maxStars = maxStars || '';
         createdBefore = createdBefore || '';
         createdAfter = createdAfter || '';
       }
     #+end_src

     This is kinda ugly, though. /Object destructuring allows default values, however/, which yields a
     much cleaner function signature:

     #+begin_src js
       function fetchRepos({ language='All', minStars=0, maxStars='', createdBefore='', createdAfter='' }) {
           // api logic
           console.log(language);
           console.log(minStars);
           console.log(maxStars);
           console.log(createdBefore);
           console.log(createdAfter);
       }
     #+end_src

     Now our api call becomes the much cleaner statement:
     #+begin_src js
       fetchRepos({
         language: 'JavaScript',
         createdBefore: new Date('01/01/2017').getTime(),
         minStars: 100,
       });
       // prints to console:
       // "JavaScript"
       // 100
       // 
       // 1483250400000
       // 
     #+end_src

**** array destructuring and function params

     Can do the same with arrays with respect to function params. Have the following function:
     #+begin_src js
       function getUserData (player) {
         // note that we wrap our function calls in an array here
         return Promise.all([
           getProfile(player),
           getRepos(player)
         ]).then(function (data) {
           // extract array vals
           const profile = data[0];
           const repos = data[1];

           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

     Side note: the above function uses *Promise*'s with calls to =getProfile= and =getRepos=, which are
     async functions. Once those promises /resolve/, we pass a function to =.then()=, which handles the
     results of the promise.

     inside of =.then()=, we declare a function that takes a param =data=, which will be an array that
     has indices. The first is the user's profile, the second is their repos. /Order matters here/
     because it's an array and because of the order of the calls we made to the functions returning
     promises.

     To take advantage of the array structure, we can destructure the values returned by our
     promises so don't need to extract them manually:

     #+begin_src js
       function getUserData (player) {
         return Promise.all([
           getProfile(player),
           getRepos(player)
         ]).then(function (data) {
           // we destructure the values of data here
           const [ profile, repos ] = data
           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

     One final improvement is, just like with objects, is to move the restructuring directly into
     the params of the function (passed to =.then()=) itself:
     
     #+begin_src js
       function getUserData (player) {
         return Promise.all([
           getProfile(player),
           getRepos(player)
           // yeet, clean code
         ]).then(([ profile, repos ]) => {
           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

** lecture 4
*** shorthand properties

    *shorthand property*: whenever you have a variable that matches the name of a property on an
    object, you can omit the property name when constructing an instance of that object.

    the following:
    #+begin_src js
      function formatMessage (name, id, avatar) {
          return {
              name: name,
              id: id,    
              avatar: avatar,    
              timestamp: Date.now()
          }
      }
    #+end_src

    can be shortened to:
    #+begin_src js
      function formatMessage (name, id, avatar) {
          return {
              name,    
              id,    
              avatar,    
              timestamp: Date.now()
          }
      }
    #+end_src
*** shorthand method
    *shorthand method names*: when a function is a property on an object, that makes it a *method*. As
     of ES6, when constructing an object that has a function as a field you can now omit the
     =function= keyword entirely.

     The following:
     #+begin_src js
       function formatMessage (name, id, avatar) {
           return {
               name,
               id,
               avatar,
               timestamp: Date.now(),
               save: function () {
                   // save message    
               }  
           }
       }
     #+end_src

     can become:
     #+begin_src js
       function formatMessage (name, id, avatar) {
           return {
               name,
               id,
               avatar,
               timestamp: Date.now(),
               // wow i saved like 8 whole keystrokes wow lol
               save () {
                   // save message    
               }  
           }
       }     
     #+end_src
** lecture 5
*** computed views
    *computed property names*: as of ES6, you can have expressions that get evaluated as properties on
    an object.

    Say you have a function that takes a (=key=, =value=) pair and returns an object that maps =key= as a
    property with =value= as its value:

    #+begin_src js
      function objectify (key, value) {
          let obj = {}
          obj[key] = value
          return obj
      }

      objectify('name', 'elias') // { name: 'elias' }
    #+end_src

    Now with computed property names you can do this:
    #+begin_src js
      function objectify (key, value) {
          return {
              [key]: value
          }
      }    
    #+end_src

    The =[]= are critical to the behavior of this feature. Note how the following function behaves:
    #+begin_src js
      function confusing_var_names(bar, bat) {
          return {
              [bar]: bat,
              is: 'forever'
          }
      }

      confusing_var_names('wu', 'tang') // returns { wu: 'tang', is: 'forever' }
    #+end_src
** lecture 6
*** template literals
    In the olden days, when you wanted to return a formatted strings with a bunch of variables
    injected into it, you had to do horrid shit like this:
    #+begin_src js
      function makeGreetingTemplate (name, email, id) {
          return '<div>' +
              '<h1>Hello, ' + name + '.</h1>' +
              '<p>We\'ve emailed you at ' + email + '. ' +
              'Your user id is "' + id + '".</p>' +
              '</div>'
      }
    #+end_src

    With *template literals*, instead of worrying about escaping all special characters and
    concatenating a bunch of strings together, you instead wrap the string with =``='s instead of
    ~""~s or ~''~s. Any expression you wish to inject into the template is surrounded by =${/* expr
    here */}=.

    Now look at the same function with template literals:

    #+begin_src js
      function makeGreetingTemplate (name, email, id) {
          return `
          <div>
            <h1>Hello, ${name}</h1>
            <p>
              We've email you at ${email}.
              Your user id is "${id}".
            </p>
          </div>
        `
      }
    #+end_src
** lecture 7
*** arrow functions
    *arrow functions* allow for more succinct code and better management over the semantics of the
    =this= keyword.

    refresh on basic structure/syntax of function declarations:

    #+begin_src js
      // function declaration
      function add (x,y) {
          return x + y;
      }

      // function expr
      const add = function (x,y) {
          return x + y;
      }
    #+end_src

    now the above function as an arrow function:
    #+begin_src js
      const add = (x,y) => {
          return x + y;
      }
    #+end_src

**** example of reducing boilerplate

     here's a shitty api function that returns a given user's tweets with > 50 faves /and/ retweets:
     #+begin_src js
       function getTweets (uid) {
         return fetch('https://api.users.com/' + uid)
           .then(function (response) {
             return response.json()
           })
           .then(function (response) {
             return response.data
           }).then(function (tweets) {
             return tweets.filter(function (tweet) {
               return tweet.stars > 50
             })
           }).then(function (tweets) {
             return tweets.filter(function (tweet) {
               return tweet.rts > 50
             })
           })
       }
     #+end_src

     note the boilerplate introduced by having to explicitly declare =function= for each anonymous
     function being passed to each =.then()= call that operates over the data returned. arrow
     functions can help remove such boilerplate which makes for a modest improvement:
     #+begin_src js
       function getTweets (uid) {
           return fetch('https://api.users.com/' + uid)
                // look ma, no function keyword
               .then((response) => {
                   return response.json()
               })
               .then((response) => {
                   return response.data
               }).then((tweets) => {
                   return tweets.filter((tweet) => {
                       return tweet.stars > 50
                   })
               }).then((tweets) => {
                   return tweets.filter((tweet) => {
                       return tweet.rts > 50
                   })
               })
       }
     #+end_src

**** implicit returns with arrow functions

     but wait! we can reduce the boilerplate even more!
     
     with arrow functions, if your function is a one-liner ("concise body"), then you can use the
     notion of *implicit returns*, which allow the omitting of the =return= keyword.

     so something like =add= can be transformed as such:
     #+begin_src js
       // old, tired
       function add(x,y) {
           return x + y;
       }
       // new, wired
       const add = (x,y) => x + y;
     #+end_src
    
     now the tweet example can be further improved as such:
     #+begin_src js
       // aight this is legit better
       function getTweets (uid) {
         return fetch('https://api.users.com/' + uid)
           .then((response) => response.json())
           .then((response) => response.data)
           .then((tweets) => tweets.filter((tweet) => tweet.stars > 50))
           .then((tweets) => tweets.filter((tweet) => tweet.rts > 50))
       }
     #+end_src

     /furthermore/, *if the arrow function only has one param, then you can drop the parentheses
     around it entirely*:
     #+begin_src js
       // NICE
       function getTweets (uid) {
         return fetch('https://api.users.com/' + uid)
           .then(response => response.json())
           .then(response => response.data)
           .then(tweets => tweets.filter((tweet) => tweet.stars > 50))
           .then(tweets => tweets.filter((tweet) => tweet.rts > 50))
       }     
     #+end_src

     [[https://thumbs.gfycat.com/ZigzagDistinctBoilweevil-max-1mb.gif]]

*** managing =this= with arrow functions
    
    arrow functions help manage the semantics of =this= because they don't *create their own context*.

    Here's a blob of react code that I don't understand/have any clue what it does:
    #+begin_src js
      class Popular extends React.Component {
          constructor(props) {
              super();
              this.state = {
                  repos: null,
              };

              this.updateLanguage = this.updateLanguage.bind(this);
          }
          componentDidMount () {
              this.updateLanguage('javascript')
          }
          updateLanguage(lang) {
              api.fetchPopularRepos(lang)
                  .then(function (repos) {
                      this.setState(function () {
                          return {
                              repos: repos
                          }
                      });
                  });
          }
          render() {
              // Stuff
          }
      }
    #+end_src

    /it doesn't work lol/. why? because it doesn't bind =this= correctly. apparently this is how you
    would fix this using ES5:

    #+begin_src js
      class Popular extends React.Component {
          constructor(props) {
              super();
              this.state = {
                  repos: null,
              };

              this.updateLanguage = this.updateLanguage.bind(this);
          }
          componentDidMount () {
              this.updateLanguage('javascript')
          }
          updateLanguage(lang) {
              api.fetchPopularRepos(lang)
                  .then(function (repos) {
                      this.setState(function () {
                          return {
                              repos: repos
                          }
                      });
                    // lol this is the fix. incredible.
                  }.bind(this)); 
          }
          render() {
              // Stuff
          }
      }
    #+end_src

    apparently people actually put up with that bullshit for like.... years. anyway, arrow functions
    make that go away. fixing the =updateLanguage= method reduces both boilerplate, makes it more
    readable, and easier to reason about because of better =this= ergonomics.

    #+begin_src js
      updateLanguage(lang) {
        api.fetchPopularRepos(lang)
          .then((repos) => {
            this.setState(() => {
              return {
                repos: repos
              }
            });
          });
      }
    #+end_src

*** "nice to knows" about arrow functions
**** differentiating function bodies and implicit returns

     say we want to optimize =updateLanguage= more by using an implicit return on the object we
     return from the nested =.then()= call.

     #+begin_src js
       api.fetchPopularRepos(lang)
           .then((repos) => {
               this.setState(() => {
                   // no more return statement
                   repos: repos
               });
           });
     #+end_src

     *problem*: this is indistinguishable from declaring a function body vs an implicit return from
     the perspective of the js interpreter. this will error out.
      
     *solution*: wrap implicit return in =()=.

     #+begin_src js
       api.fetchPopularRepos(lang)
           .then((repos) => {
                                   // here, we wrap the {} with ()
               this.setState(() => ({
                   repos: repos
               })); // note extra closing )
           });
     #+end_src

**** leverage shorthand property and method names with arrow functions

     can further improve the above snippet by dropping the field name entirely since the variable
     and field are named the same. this allows us to also drop the wrapping ={}= and =()='s entirely.

     #+begin_src js
       api.fetchPopularRepos(lang)
           .then((repos) => 
               this.setState(() => repos)
           );
     #+end_src

**** logging inside of arrow functions with implicit returns

     how would you log the state within the component function above? one solution would be to
     return the explicit =return= statement so you can add a console call before it:

     #+begin_src js
       this.setState((nextState) => {
           console.log(nextState)
           return {
               repos: repos
           }
       });
     #+end_src

     it works, but it makes us re-add a bunch of boilerplate just for logging. in classic javascript
     fashion, let's do some really janky shit that works and is seemingly encouraged so we can keep
     our code ""clean"":
     #+begin_src js
       this.setState((nextState) => console.log(nextState) || ({
           repos: repos
       }));
     #+end_src

     ... /nice? i guess?/
     
** lecture 8
*** default params

    traditional approach to setting default values for function arguments was to use =||= to check for
    false-y values like =undefined= and =0=.

    so if we have a function that calculates payment and takes the arguments =price=, =salesTax=, and
    =discount= where only =price= is required, we could define =0.5= and =0= as the default values for the
    latter params respectively:
    #+begin_src js
      function calcPayment(price, salesTax, discount) {
          salesTax = salesTax || 0.5;
          discount = discount || 0;
          // stuff
      }
    #+end_src

    *problem*: what happens when the function consumer passes 0 to =salesTax=? given =0= is taken as
     false-y, that means it will get incorrectly overwritten by the default value! what needs to
     happen instead of checking for false-y values is checking for /undefined/ values.

    #+begin_src js
      function calcPayment(price, salesTax, discount) {
          salesTax = typeof salesTax === 'undefined' ? 0.5 || salesTax;
          discount = typeof discount === 'undefined' ? 0 || discount;
          // stuff
      }    
    #+end_src

    works as intended, but now it's kinda verbose.

    ES6 has *default parameters*, which achieve the desired behavior above but with a cleaner syntax:
    #+begin_src js
      function calcPayment(price, salesTax = 0.5, discount = 0) {
          // stuff
      }
    #+end_src
*** "required" arguments

    what if you want to /enforce/ required arguments by throwing an exception when a function is not
    given one? define a function like so:
    #+begin_src js
      function isRequired(name) {
          throw new Error(`${name} is required`)
      }
    #+end_src

    and now you can simply wrap the required parameter with a default value specifying it's name:
    #+begin_src js
      function calcPayment(price = isRequired('price'), 
                           salesTax = 0.5,
                           discount = 0) {
          // stuff
      }    
    #+end_src

    *nice*. whether this type of defensive programming is "good" or not is on you/your
     team/god/whatever.
** lecture 9
*** compiling vs Polyfills with Babel

    js is constantly changing and being updated which results in the browser ecosystem becoming
    fractured and lagging in terms of feature implementations. there are two things that can be done
    to fix this.

    the first major thing is transpiling your modern js into equivalent js that uses older, more
    widely supported syntax and features. this is traditionally done via Babel. look at the
    following modern example code and its transformation:
    #+begin_src js
      // new, fancy js
      const getProfile = username => {
          return fetch(`https://api.github.com/users/${username}`)
              .then((response) => response.json())
              .then(({ data }) => ({
                  name: data.name,
                  location: data.location,
                  company: data.company,
                  blog: data.blog.includes('https') ? data.blog : null
              }))
              .catch((e) => console.warn(e))
      }

      // transformed js via babel
      var getProfile = function getProfile(username) {
        return fetch('https://api.github.com/users/' + username).then(function (response) {
          return response.json();
        }).then(function (_ref) {
          var data = _ref.data;
          return {
            name: data.name,
            location: data.location,
            company: data.company,
            blog: data.blog.includes('https') ? data.blog : null
          };
        }).catch(function (e) {
          return console.warn(e);
        });
      };
    #+end_src

    this will be guaranteed to work in older browsers by transforming newer ES6 features into js
    that browsers know how to execute.... /almost/.

    notice that the =fetch= and =includes= function calls were not transformed into their "analog"
    equivalents of =indexOf= and =XMLHttpRequest= despite their "newness". why didn't this occur?  babel
    only transforms your newer syntax into older equivalents and *does not handle new javascript
    primitives or properties required for the browser's global namespace*.

    to finish the transformation into functional js that more browsers can use, *Polyfill* is required
    to inject the remaining features and properties to make newer code work.

    there is a long ass list of features that babel specifies as supported or in need of
    polyfilling. rather than reading them, just [[https://babeljs.io/][use their documentation to know when polyfill is needed]]. 
** lecture 10

   not all websites can be static, which means having to cope with things like asynchronously
   handling data and events.
*** callbacks
    
    javascript allows for function composition. a function that takes another function as an
    argument is a *higher order function*. in js land, a function passed to a HO function is a
    *callback function*.

    #+begin_src js
      const add = (x,y) => x + y;
      const addFive = (x, addRef) => addRef(x, 5);
    #+end_src

    there are two popular uses for callback functions:
    1. transforming values via fp patterns like =.map()=
    2. delaying the execution of a function until some time/event occurs

       JQuery stuff is a good example for this:
       #+begin_src js
         $('#button').on('click', () => 
           console.log('ya clicked me'))
       #+end_src

       
    the examples thus far have been synchronous, but the latter case is what async programming
    concerns. instead of delaying a function until some event occurs, /we can delay a function until
    we get the data we need/.

    why use async? otherwise, code like the following results in websites that delay full
    loading/rendering until the query finishes its completion:
    #+begin_src js
      // updateUI and showError are irrelevant.
      // Pretend they do what they sound like.

      const id = 'tylermcginnis'

      $.getJSON({
        url: `https://api.github.com/users/${id}`,
        success: updateUI,
        error: showError,
      })
    #+end_src

    /the UI cannot be updated until we have the user's data/. this is undesirable for user facing
    applications. instead, we can ask our program to execute as normal while waiting for a piece of
    data to finish processing/being requested. if it succeeds, update the UI as necessary. if it
    doesn't, maybe throw an error or otherwise handle the exception as necessary. this is what async
    programming allows us to do.

*** darkside of callbacks

    *callback hell* occurs from the original way of handling async events in js. instead of nice,
     clean, and linear code that "sequentially" handles logic that is, in all reality, asynchronous,
     you get a pyramid of death that requires a lot of mental overhead to solve. take the following
     example:
     #+begin_src js
       // updateUI, showError, and getLocationURL are irrelevant.
       // Pretend they do what they sound like.

       const id = 'tylermcginnis'

       // yikes!
       $("#btn").on("click", () => {
           $.getJSON({
               url: `https://api.github.com/users/${id}`,
               success: (user) => {
                   $.getJSON({
                       url: getLocationURL(user.location.split(',')),
                       success (weather) {
                           updateUI({
                               user,
                               weather: weather.query.results
                           })
                       },
                       error: showError,
                   })
               },
               error: showError
           })
       })
     #+end_src
     
     the above code says the following:
     - don't run the AJAX request until the =btn= element is clicked
     - once clicked, make the first request for the user's github
       + if the request fails, show an error
     - if that request succeeds, invoke =updateUI=
       + otherwise, show an error

         
     this pattern of callback programming is difficult to mentally parse and is error
     prone. modularizing the code can help to some degree, but then introduces a significant amount
     of boilerplate code that makes what is  happening ostensibly harder to understand as the logic
     is now broken between a bunch of smaller code snippets like so:
     #+begin_src js
       function getUser(id, onSuccess, onFailure) {
           $.getJSON({
               url: `https://api.github.com/users/${id}`,
               success: onSuccess,
               error: onFailure
           })
       }

       function getWeather(user, onSuccess, onFailure) {
           $.getJSON({
               url: getLocationURL(user.location.split(',')),
               success: onSuccess,
               error: onFailure,
           })
       }

       $("#btn").on("click", () => {
           getUser("tylermcginnis", (user) => {
               getWeather(user, (weather) => {
                   updateUI({
                       user,
                       weather: weather.query.results
                   })
               }, showError)
           }, showError)
       })
     #+end_src

**** inversion of control

     aside from callback hell, callbacks tend to introduce *inversion of control*. when you hand off
     your callback function to the consuming HO function, you are /assuming/ the receiving program
     will be responsible and /only use the callback when it's supposed to/. you are handing the
     control of your program to another program. with 3rd party libraries, there is a good chance
     the API will result in unintended behavior as the library either intentionally or accidentally
     breaks the logic of the callback.

     #+begin_src js
       function criticalFunction () {
           // It's critical that this function
           // gets called and with the correct
           // arguments.
       }

       thirdPartyLib(criticalFunction)
     #+end_src

     in the above snippet, you have /zero control of whether or how =criticalFunction= is called/

*** Promises

    Rather than giving away /your/ callback to a program and hoping they use it as intended, we can
    make programs /promise/ to do something for /us/.

    A *promise* can be in one of three states:
    - *pending*
    - *fulfilled*
    - *rejected*

      
    *promises* were introduced to reduce the complexity of making async requests.

**** how do you create a promise?

     straightforward: create a =new= instance of a =Promise=:
     #+begin_src js
       const promise = new Promise()
     #+end_src

**** how do you change the status of a promise?

     the =Promise= constructor takes one argument: the callback function. inside of this function you
     do whatever async action/logic you need. in addition to this, the callback will, in turn, be
     given two arguments:
     1. =resolve=: a function that allows you to change the status of the promise to =fulfilled=
     2. =reject=: a function that allows you to change the status of the promise to =rejected=

        
     each will get called in their respective case of success or failure of the promise.

     here's a trivial example that only executes the successful case of =resolve=:
     #+begin_src js
       const promise = new Promise((resolve, reject) => {
           // set to resolve in 2 seconds
           setTimeout(() => {
               resolve()
           }, 2000)
       });

       // check status of promise
       console.log('promise is pending -', promise);

       // wait 2 seconds to check again
       setTimeout(() => {
           console.log('promise should be resolved -', promise)
       }, 2000);
     #+end_src

**** how do you listen for when the status of a promise changes?

     probably the most critical aspect of Promises is what to do with them.

     underneath the hood, =Promises= are plain javascript objects with two methods, which each take a
     function:
     1. *then()*: when the status of the promise is changed to =fulfilled=, the function passed to
        =then()= gets invoked, often on the data returned by the promise.
     2. *catch()*: when the status of the promise is changed to =rejected=, the function passed to
        =catch()= gets invoked. this can handle any error codes, data handled to it or take
        alternative action.

        
     the following code creates two different promises that demonstrate the execution of =then()= and
     =catch()= respectively:
     #+begin_src js
       function onSuccess () {
         console.log('Success!')
       };

       function onError () {
         console.log('ðŸ’©')
       };

       const promise1 = new Promise((resolve, reject) => {
         setTimeout(() => {
           resolve()
         }, 2000)
       });

       promise1.then(onSuccess);
       promise1.catch(onError);

       const promise2 = new Promise((resolve, reject) => {
         setTimeout(() => {
           reject()
         }, 2000)
       });

       promise2.then(onSuccess);
       promise2.catch(onError);
     #+end_src

     
*** chaining
    both =then()= and =catch()= *return a promise*. this is critical because it then allow us to *chain*
    promises.

    here's a contrived example that shows how we can log a sequence of promises by chaining:
    #+begin_src js
      function getPromise () {
          return new Promise((resolve) => {
              setTimeout(resolve, 2000)
          })
      }

      function logA () {
          console.log('A')
      }

      function logB () {
          console.log('B')
      }

      function logCAndThrow () {
          console.log('C')

          throw new Error()
      }

      function catchError () {
          console.log('Error!')
      }

      getPromise()
          .then(logA) // A
          .then(logB) // B
          .then(logCAndThrow) // C
          .catch(catchError) // Error!
    #+end_src

    *chaining* allows us to use promises in such a way that our code maintains a linear form which
     makes reasoning about asynchronous logic easier.





     returning to the modularized callback hell example, we can now refactor it into legitimately
     clean and straightforward code via =Promise='s and chaining:
     #+begin_src js
       function getUser(id) {
           return new Promise((resolve, reject) => {
               $.getJSON({
                   url: `https://api.github.com/users/${id}`,
                   success: resolve,
                   error: reject
               })
           })
       }

       function getWeather(user) {
           return new Promise((resolve, reject) => {
               $.getJSON({
                   url: getLocationURL(user.location.split(',')),
                   success: resolve,
                   error: reject,
               })
           })
       }

       $("#btn").on("click", () => {
           getUser("tylermcginnis")
               .then(getWeather)
               .then((weather) => {
                   // We need both the user and the weather here.
                   // Right now we just have the weather
                   updateUI() // ????
               })
               .catch(showError)
       })
     #+end_src

     already, this code looks better; however, we still have a problem. inside of our actual JQuery
     call, when we get to the =.then()= call on the results of the =getWeather= promise, we only have
     access to =weather= as a value but need =user= as well. How do we ensure =user= gets passed along the
     promise chain?

*** resolve
    *resolve*: =resolve()= is a function that allows you to pass on any arguments to the next =then()=
    invocation on a chain of promises.

    refactoring =getWeather= to use =resolve()=:
    #+begin_src js
      function getWeather(user) {
          return new Promise((resolve, reject) => {
              $.getJSON({
                  url: getLocationURL(user.location.split(',')),
                  success(weather) {
                      // in our success case, we call resolve() and just
                      // pass what we need to make it into the next .then() call
                      resolve({ user, weather: weather.query.results })
                  },
                  error: reject,
              })
          })
      }
    #+end_src

    Now our JQuery call becomes:
    #+begin_src js
      $("#btn").on("click", () => {
          getUser("tylermcginnis")
              .then(getWeather)
              .then((data) => updateUI(data))
              .catch(showError)
      })
    #+end_src

    much cleaner.

*** improvements to chaining and resolve

    our code is nice, but could we make it nicer? what if we could write it like normal synchronous
    code:
    #+begin_src js
      $("#btn").on("click", () => {
          const user = getUser('tylermcginnis')
          const weather = getWeather(user)

          updateUI({
              user,
              weather,
          })
      })
    #+end_src

    in this situation, we have what looks like /truly synchronous/ code that actually behaves
    asynchronously; however, this would make the js engine kill itself. it's hiding the fact that
    each function invocation within it is returning a promise, and pretending otherwise won't make
    it go away.

    but what if... we could explicitly tell js that we were making an *async* function?
    #+begin_src js
                            // "hey js repl, this arrow function is async, watch out okay?
      $("#btn").on("click", async () => {
          const user = getUser('tylermcginnis')
          const weather = getWeather(user)

          updateUI({
              user,
              weather,
          })
      })
    #+end_src

    alright, but now how does the js interpreter know where in this function call is the async
    behavior that it has to wait on? tell it by using the *await* keyword:
    #+begin_src js
      $("#btn").on("click", async () => {
          const user = await getUser('tylermcginnis')
          const weather = await getWeather(user.location)

          updateUI({
              user,
              weather,
          })
      })
    #+end_src

    *async functions* return promises while *await* halts the execution of an async function until the
    expression following it returns /something/.

*** error handling

    when using async/await, instead of using =catch()= as with non-async/await chaining of promises,
    wrap them in *try/catch* blocks:
    #+begin_src js
      $("#btn").on("click", async () => {
          try {
              const user = await getUser('tylermcginnis')
              const weather = await getWeather(user.location)

              updateUI({
                  user,
                  weather,
              })
          } catch (e) {
              showError(e)
          }
      })
    #+end_src

** lecture 11
*** objects
    *objects* are key/value pairs and are a central structure to js.

    an example of instantiating an object using the standard ={}= and dot notation:
    #+begin_src js
      let animal = {};
      animal.name = "tux";
      animal.energy = 10;

      animal.eat = function (amount) {
          console.log(`${this.name} is eating`);
          this.energy += amount;
      }

      animal.sleep = function(length) {
          console.log(`${this.name} is sleeping`);
          this.energy += length;
      }

      animal.play = function(length) {
          console.log(`${this.name} is playing`);
          this.energy -= length;
      }
    #+end_src

*** functional instantiation
    *Functional Instatiation* is creating a function that acts as a constructor for a type of object.
    
    we can encapsulate the logic above into a general constructor for animal objects as so:
    #+begin_src js
      function Animal (name, energy) {
          let animal = {};
          animal.name = name;
          animal.energy = energy;

          animal.eat = function (amount) {
              console.log(`${this.name} is eating`);
              this.energy += amount;
          }

          animal.sleep = function(length) {
              console.log(`${this.name} is sleeping`);
              this.energy += length;
          }

          animal.play = function(length) {
              console.log(`${this.name} is playing`);
              this.energy -= length;
          }

          return animal
      }
    #+end_src
    
    simple enough, but what are some weaknesses of this approach?
    - each method is dynamic, i.e. is re-created for each call to =Animal()=, when they are generic in
      nature.
      + i.e. we are wasting memory and making each =Animal= object larger than necessary.


    solution?

*** Functional Instantiation with Shared Methods

    *Functional Instatiation with Shared Methods* is when methods shared by different objects are
    defined on a single object type that the sharing objects reference for their own instantiation.

    Taking =Animal= as our example:
    #+begin_src js
      function animalMethods = {
          eat = function (amount) {
              console.log(`${this.name} is eating`);
              this.energy += amount;
          }

          sleep = function(length) {
              console.log(`${this.name} is sleeping`);
              this.energy += length;
          }

          play = function(length) {
              console.log(`${this.name} is playing`);
              this.energy -= length;
          }
      }

      function Animal (name, energy) {
          let animal = {};
          animal.name = name;
          animal.energy = energy;

          // now attach the method reference to our new animal
          animal.eat = animalMethods.eat;
          animal.sleep = animalMethods.sleep;
          animal.play = animalMethods.play;

          return animal
      }
    #+end_src

*** Object.create
    Can further implementation via *Object.create*.

    =Object.create= allows you to create an object which will delegate to another object on failed
    lookups, i.e. whenever a property that does not exist is looked up against an object, the
    delegated object will then be checked for that property.

    example:
    #+begin_src js
      const grandparent = {
          name: 'cato the elder',
          age: 60,
          heritage: 'patrician'
      }

      const grandchild = Object.create(grandparent);
      grandchild.name = 'cato the younger';
      grandchild.age = 20;

      console.log(grandchild.name);
      console.log(grandchild.heritage);
    #+end_src

*** Functional Instatiation with Shared Methods and Object.create

    why does =Object.create= matter here? we can now replace all those spurious field calls with a
    single call to =Object.create= to associate an animal with the shared methods of =animalMethods=

    #+begin_src js
      const animalMethods = {
        eat(amount) {
          console.log(`${this.name} is eating.`)
          this.energy += amount
        },
        sleep(length) {
          console.log(`${this.name} is sleeping.`)
          this.energy += length
        },
        play(length) {
          console.log(`${this.name} is playing.`)
          this.energy -= length
        }
      }

      function Animal (name, energy) {
        // see ma, no hands
        let animal = Object.create(animalMethods)
        animal.name = name
        animal.energy = energy

        return animal
      }
    #+end_src

    nice. /but doesn't it still feel hacky to have a whole separate function type separate from
    =Animals= themselves?/ How can this be avoided? The answer lies in *prototypes*.

    every function in js has a *prototype property* that references an object. the solution for
    =Animal='s then is to put the shared methods, instead of inside a separate function, on the
    prototype of =Animal= itself. Then we can delegate to =Animal.prototype= instead of a separate
    function object. This pattern is called...

*** Prototypal Instantiation
    
    Let's use *prototypal instantiation* on =Animal= to implement its shared functions:
    #+begin_src js
      function Animal (name, energy) {
          let animal = Object.create(Animal.prototype)
          animal.name = name
          animal.energy = energy

          return animal
      }

      Animal.prototype.eat = function (amount) {
          console.log(`${this.name} is eating.`)
          this.energy += amount
      }

      Animal.prototype.sleep = function (length) {
          console.log(`${this.name} is sleeping.`)
          this.energy += length
      }

      Animal.prototype.play = function (length) {
          console.log(`${this.name} is playing.`)
          this.energy -= length
      }
    #+end_src

    every instance of the function =Animal= will now have access to these methods. nice.

*** psuedo-classical instantiation

    why is javascript so lame? why does it not already support the features we created using
    prototypes and shared methods? actually, it does via the =new= keyword. using =new=, we can define a
    constructor function that elides the call to =Object.create= its =return= statement because it does
    this implicitly using =this= as a reference to the new object instantiated.

    in other words, if we used =new= with =Animal=, this is all that would be needed:
    #+begin_src js
      function Animal (name, energy) {
          // elided bc happens implicitly
          // const this = Object.create(Animal.prototype)

          this.name = name
          this.energy = energy
          // same again here
          // return this
      }
    #+end_src

    thus, this will work:
    #+begin_src js
      function Animal (name, energy) {
          this.name = name
          this.energy = energy
      }

      Animal.prototype.eat = function (amount) {
          console.log(`${this.name} is eating.`)
          this.energy += amount
      }

      Animal.prototype.sleep = function (length) {
          console.log(`${this.name} is sleeping.`)
          this.energy += length
      }

      Animal.prototype.play = function (length) {
          console.log(`${this.name} is playing.`)
          this.energy -= length
      }

      const tux = new Animal('tux', 10);
    #+end_src


    if you were to call =Animal= without =new=, the =this= object is never created nor returned.

    #+begin_src js
      const vlad = Animal('vlad', 5);
      console.log(vlad); // undefined
    #+end_src

    the pattern for using =new= and attaching shared methods to the prototype of a function is called
    *pseudo-classical instantiation*

*** classes

    it's kinda funny imo how it took till 2015 for javascript to just make =class= a thing, but
    whatever. anyway, yeah, ES6 implemented =class= as a feature, but *=class= is just syntactic sugar
    for the psuedo-classical instantiation pattern* we learned about above. it's nothing special in
    the end.

    to use =class= syntax for =Animal=:
    #+begin_src js
      class Animal {
          constructor(name, energy) {
              this.name = name
              this.energy = energy
          }
          eat(amount) {
              console.log(`${this.name} is eating.`)
              this.energy += amount
          }
          sleep(length) {
              console.log(`${this.name} is sleeping.`)
              this.energy += length
          }
          play(length) {
              console.log(`${this.name} is playing.`)
              this.energy -= length
          }
      }

      const tux = new Animal('tux', 10);
    #+end_src

*** array methods
    connecting to js classes and prototypes, the methods provided for array
    manipulation/transformation are a result of the same pattern.

    if you evaluate =console.log(Array.prototype)= in the developer console on your browser, you will
    see something like:

    [[file:assets/Screenshot_20200525_131458.png]]

    
    this goes for all Objects in js. whenever if an property gets looked up against an object and it
    doesn't exist, along for each delegated object, then eventually it gets looked up against
    =Object.prototype= itself. this is why all objects have methods like =toString()= and
    =hasOwnProperty()=

*** static methods

    what if an object entity has a method that is unique to that object type (class, function, etc)
    but does not need to be shared across each instance, i.e. each instance can use the same single
    function across each rather than having their own? this is a *static method* by definition, and
    its declared within the =class= declaration like any other function aside from being prefixed with
    the =static= keyword.

    for animal, we might have a method that determines which animal, of all the animals, needs to be
    fed next:
    #+begin_src js
      class Animal {
          /* other methods */
          static nextToEat(animals) {
              const sortedByLeastEnergy = animals.sort((a,b) => {
                  return a.energy - b.energy
              })

              return sortedByLeastEnergy[0].name
          }
      }

      const leo = new Animal('Leo', 7)
      const snoop = new Animal('Snoop', 10)

      console.log(Animal.nextToEat([leo, snoop])) // nice
    #+end_src

    =static= is syntactic sugar just like =class= is and in ES5 would otherwise be implemented as so:
    #+begin_src js
      Animal.nextToEat = function (nextToEat) {
          const sortedByLeastEnergy = animals.sort((a,b) => {
              return a.energy - b.energy
          })

          return sortedByLeastEnergy[0].name
      }
    #+end_src
    where we make the function a property of /the =Animal= function/ rather than its /prototype/

*** getting the prototype of an object

    regardless of how an object was instantiated, you can always get a reference to its =prototype=
    via =.getPrototypeOf()=:
    #+begin_src js
      const tux = new Animal('tux', 10);
      const tux_proto = Object.getPrototypeOf(tux);
      console.log(tux_proto); // {constructor: Æ’, eat: Æ’, sleep: Æ’, play: Æ’}

      tux_proto === Animal.prototype // true
    #+end_src


    two major takeaways:
    1. =prototype='s have every method defined on them + their constructor
       - this means that an instance of an object can access its own constructor
       - this occurs via delegation via =Object.create=, which implicitly happens between an object
         instance and its prototype using js =class='s and/or the pseudo-classical instantiation pattern
    2. =Animal.prototype= is the reference returned by =Object.getPrototypeOf(tux)= because they are the
       same thing
       - i don't know why mcginnis thinks this is worth saying, i guess he's just affirming it w/e

         
    side note: *.__proto__* is considered legacy, don't use that.

*** determining if a property lives on a prototype

    special cases arise where you want to know whether a property lives on an object instance or the
    prototype it delegates to.

    we can't use a =for in= loop because it'll return every property on an object instance, including
    its prototype's:
    #+begin_src js
    for(let key in tux) {
        console.log(`Key: ${key}. Value: ${tux[key]}`);
    }
    #+end_src

    as already said, it'll yield /every property/ on the object, including the object's prototype:
    #+begin_src js
      Key: name. Value: tux
      Key: energy. Value: 10
      Key: eat. Value: function (amount) {
          console.log(`${this.name} is eating.`)
          this.energy += amount
      }
      Key: sleep. Value: function (length) {
          console.log(`${this.name} is sleeping.`)
          this.energy += length
      }
      Key: play. Value: function (length) {
          console.log(`${this.name} is playing.`)
          this.energy -= length
      }
    #+end_src

    this is because =for in= loops iterate over all of the *enumerable properties* available on that
    object.

    to determine whether a property exists strictly /on an object instance/, use the boolean function =hasOwnProperty()=
    instead, which takes a property and checks whether the object has it:
    #+begin_src js
      for (let key in tux) {
          if (tux.hasOwnProperty(key)) {
              console.log(`Key: ${key}. Value: ${tux[key]}`);
          }
      }
    #+end_src

    which will yield the desired results:
    #+begin_src js
      Key: name. Value: tux
      Key: energy. Value: 10
    #+end_src

*** check if object is an instance of class
    =instanceOf= /operator/ does the trick:
    #+begin_src js
      tux instanceOf Animal // true
    #+end_src

    it functions by checking for the existence of the =constructor.prototype= in the object's
    prototype chain. this is true for =tux= because:
    #+begin_src js
      Object.getPrototypeOf(tux) === Animal.prototype
    #+end_src

*** creating new agnostic constructor functions

    how do you ensure a constructor function is always called with =new=? otherwise =this= is never
    constructor nor returned implicitly. to enforce this, realize that the =this= instance inside the
    constructor, if correctly called with =new=, will be an =instanceOf= that class. thus, we could do
    the following to enforce the usage of =new=:
    #+begin_src js
      function Animal(name, energy) {
          if (this instanceOf Animal === false) {
              throw new Error('did not construct object using new')
          }
          /* rest of code */
      }
    #+end_src

    better yet (is it really?).... we could just correct the error ourselves:
    #+begin_src js
      function Animal(name, energy) {
          if (this instanceOf Animal === false) {
              console.warn("failed to call Animal with new. corrected");
              return new Animal(name, energy)
          }
          /* rest of code */
      }    
    #+end_src

*** recreating the =Object.create()= method
    
    #+begin_src js
      Object.create = function(objToDelegate) {
          function Fn(){}
          Fn.prototype = objToDelegate;
          return new Fn()
      }
    #+end_src

    What is happening above:
    1. we create a function called =create= on the =Object= class
    2. inside that function, we define an empty function, =Fn=
    3. since every function has a prototype property, we assign to =Fn='s prototype the object we're
       delegating to
    4. finally, we use =new= to create /a new instance of that object/, which is what our empty =Fn=
       achieves because its prototype is that of the delegated object
       - thus, when we create a new object via =Object.create()=, the returned object, being an empty
         function, everything gets delegated to the passed object type's prototype.

*** arrow functions
    
    friendly reminder that arrow functions don't have =this= because they don't introduce their own
    context. by natural extension, this means they cannot be constructors. trying to do otherwise
    will return an error.

** lecture 12

*** why modules
    - reusability
    - composability
    - isolation
    - organization

*** js modules
    *modules*, generally speaking, are collections of code that together have a specific purpose with
    clear boundaries on its functionality and integration with other modules

    in js land, each module has three parts:
    1. imports (aka dependencies) - outside modules needed by the current module to function
    2. code - the actual code, i.e. logic/functionality, of th module
    3. exports (aka the interface) - the units of code exposed to the outside world and to be used by
       other modules

       
    here's an example taken out of the modules directory of the React Router library:
    #+begin_src js
      // imports
      import React from "react";
      import { createMemoryHistory } from "history";
      import Router from "./Router";

      // code
      class MemoryRouter extends React.Component {
          history = createMemoryHistory(this.props);
          render() {
              return (
                  <Router
                      history={this.history}
                      children={this.props.children}
                  />;
              )
          }
      }

      // exports
      export default MemoryRouter;
    #+end_src

*** js modules from the ground up

    js has a bad and weird history with modules so understanding how they work from the ground up
    can help with legacy code that still exists out there or something idk

    let's pretend it's the late 2000s. JQuery is the hot shit and people are starting to build
    enterprise size apps with js.

**** modules by file

     what if we made each file a module?
     #+begin_src js
       // users.js
       var users = ["odb", "rza", "gza"]

       function getUsers() {
         return users
       }

       // dom.js

       function addUserToDOM(name) {
         const node = document.createElement("li")
         const text = document.createTextNode(name)
         node.appendChild(text)

         document.getElementById("users")
           .appendChild(node)
       }

       document.getElementById("submit")
         .addEventListener("click", function() {
           var input = document.getElementById("input")
           addUserToDOM(input.value)

           input.value = ""
       })

       var users = window.getUsers()
       for (var i = 0; i < users.length; i++) {
         addUserToDOM(users[i])
       }
     #+end_src

     and here's how we serve it on our index.html:
     #+begin_src html
       <!-- index.html -->
       <!DOCTYPE html>
       <html>
         <head>
           <title>Users</title>
         </head>

         <body>
           <h1>Users</h1>
           <ul id="users"></ul>
           <input
             id="input"
             type="text"
             placeholder="New User">
           </input>
           <button id="submit">Submit</button>

           <script src="users.js"></script>
           <script src="dom.js"></script>
         </body>
       </html>
     #+end_src

     does this work? *nope*. nothing about how we've setup our files make them modules. as it stands,
     only functions can create their own contexts and thus every variable and function in each of
     the two files is introduced into the global namespace of our webpage. opening up the web
     console confirms this when you check our =window= object: 

     [[file:assets/Screenshot_20200525_155543.png]]

     =addUsers=, =users=, =getUsers=, and =addUsersToDOM= are all accessible. physical separation of code is
     the only thing achieved by our current setup.

     what can we do to actually modularize this code? what features, native to vanilla js, enable
     this sort of encapsulation?

     .... /what if we just wrap it all up in a function?/ let's make a single object, =APP=, that we
     expose at the global namespace level and put everything else about our app inside of it. We can
     put everything else in wrapper functions to keep it from polluting our global namespace.

     #+begin_src js
       // App.js
       var APP = {}


       // users.js
       function usersWrapper () {
         var users = ["odb", "rza", "gza"]

         function getUsers() {
           return users
         }

         APP.getUsers = getUsers
       }

       usersWrapper()


       // dom.js

       function domWrapper() {
         function addUserToDOM(name) {
           const node = document.createElement("li")
           const text = document.createTextNode(name)
           node.appendChild(text)

           document.getElementById("users")
             .appendChild(node)
         }

         document.getElementById("submit")
           .addEventListener("click", function() {
             var input = document.getElementById("input")
             addUserToDOM(input.value)

             input.value = ""
         })

         var users = APP.getUsers()
         for (var i = 0; i < users.length; i++) {
           addUserToDOM(users[i])
         }
       }

       domWrapper()
     #+end_src

     and add the following line before our other script calls in index.html:
     #+begin_src html
       <script src="app.js"></script>
     #+end_src


     looking at our =window= object, we now see there's a lot less pollution with only =APP= and our
     wrapper functions exposed. furthermore, because everything is inside of =APP= and wrapped up,
     none of the important code is exposed for direct manipulation like =users= was before.

     [[file:assets/Screenshot_20200525_155622.png]]

     is there way to go even further? can we eliminate the wrapper functions?

     note how we define and *then immediately invoke* our wrapper functions upon being loaded by their
     script tags in index.html. the only reason why they even have names is because we need to
     invoke them immediately, afterwards becoming useless to the client.

     ideally, we want a way to immediately invoke anonymous functions that setup the infrastructure
     of our application without polluting the global namespace with useless helpers/wrappers that
     don't do anything.

     what we want is called *Immediately Invoked Function Expressions*, aka *IIFE*'s

*** Immediately Invoked Function Expressions (IIFE)

    An *Immediately Invoked Function Expression* is an anonymous js function wrapped in parentheses
    that is immediately invoked upon evaluation by adding a trailing =()=:
    #+begin_src js
      (function () {
          console.log('look 'ma no hands)
      })()
    #+end_src

    note, the trailing =()= are necessary to invoke the function as is necessary for any js function
    to be invoked, e.g. =.toString()= vs =.toString=. evaluating only the expression wrapped in =()=
    results in nothing happening.

    let's apply our knowledge of IIEF's to our example application:
    #+begin_src js
      // App.js
      var APP = {}

      // users.js
      (function () {
          var users = ["odb", "rza", "gza"]

          function getUsers() {
              return users
          }

          APP.getUsers = getUsers
      })()

      // dom.js

      (function () {
          function addUserToDOM(name) {
              const node = document.createElement("li")
              const text = document.createTextNode(name)
              node.appendChild(text)

              document.getElementById("users")
                  .appendChild(node)
          }

          document.getElementById("submit")
              .addEventListener("click", function() {
                  var input = document.getElementById("input")
                  addUserToDOM(input.value)

                  input.value = ""
              })

          var users = APP.getUsers()
          for (var i = 0; i < users.length; i++) {
              addUserToDOM(users[i])
          }
      })()
    #+end_src

    our index.html remains untouched. 

    now when we eval =window= in our developer console, we get:
    [[file:assets/Screenshot_20200525_165228.png]]

    /perfecto/

    this pattern is called the *IIFE Module Pattern*

**** benefits of the IIFE Module Pattern
     avoid dumping everything into the global namespace
     - avoid collisions
     - keep code private

**** cons of IIFE Module Pattern
     - have one item in global namespace, =APP=
       + if anything else tries to use this name, trouble abounds
     - order of =<script>= tags matters a lot, problems will occur otherwise

*** module exports
    *each file is (nominally) its own module*, we just need to make it work by defining *explicit
    imports* and *explicit exports*.

    our module standard becomes:
    1. file based
    2. explicit imports
    3. explicit exports

*** defining our module api

    any information regarding the module can go on the *module* object so that anything we want to
    export we simply stick on =module.exports=:

    #+begin_src js
      var users = ["odb", "rza", "gza"]

      function getUsers() {
          return users
      }

      module.exports.getUsers = getUsers
    #+end_src

    equivalently:
    #+begin_src js
      var users = ["odb", "rza", "gza"]

      function getUsers() {
          return users
      }

      module.exports = {
          getUsers: getUsers
      }
    #+end_src

    we can make it even more condensed, and arbitrarily add as many exports as necessary:
    #+begin_src js
      // users.js
      var users = ["odb", "rza", "gza"]

      module.exports = {
          getUsers: function () {
              return users
          },
          sortUsers: function () {
              return users.sort()
          },
          // and so on
      }
    #+end_src

    now we need to resolve our import API. for simplicity, assume we have a function =require()= that
    takes a string path as its first argument and will return whatever is being exported from that
    path.

    to import our =users.js= file, we would do something like:
    #+begin_src js
      var users = require('./users')

      users.getUsers() // ["odb", "rza", "gza"]
    #+end_src

    we now have all the benefits of IIFE without any of the weird stuff. furthermore, this is of
    course a real standard, *CommonJS*

    #+begin_quote
    The CommonJS group defined a module format to solve JavaScript scope issues by making sure each
    module is executed in its own namespace. This is achieved by forcing modules to explicitly
    export those variables it wants to expose to the â€œuniverseâ€, and also by defining those other
    modules required to properly work.

    - Webpack docs
    #+end_quote

    this is more or less what node.js does, though it partially deviates from the spec. furthermore,
    browsers don't actually support =CommonJS= because *of its synchronous loading* of modules. Async is
    king in browser land.

    thus the two downsides of =CommonJS= are:
    1. browsers don't know it
    2. even if they did, it would be a bad UX because of synchronous loading.

*** Module Bundlers

    *javascript bundlers* examine your codebase, look at all the imports and exports, then
    intelligently bundles all of your modules together into a single file that the browser can
    understand. finally, instead of worrying about a shitton of =<script>= tags and their ordering,
    you just include a single =bundle.js= file to load.

    the process looks like:
    #+begin_quote
    app.js ---> |         |
    users.js -> | Bundler | -> bundle.js
    dom.js ---> |         |
    #+end_quote

    where all your files get inputted into the Bundler, and the Bundler gives you a functional
    =bundle.js= file to use and that the browser will understand.

    how do Bundlers work? *good question*, Tyler McGinnis doesn't understand them fully
    neither. However, here's what our code (=users.js= and =dom.js=) would look like went put through a
    basic webpack config:
    #+begin_src js
      (function(modules) { // webpackBootstrap
        // The module cache
        var installedModules = {};
        // The require function
        function __webpack_require__(moduleId) {
          // Check if module is in cache
          if(installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          // Create a new module (and put it into the cache)
          var module = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          // Execute the module function
          modules[moduleId].call(
            module.exports,
            module,
            module.exports,
            __webpack_require__
          );
          // Flag the module as loaded
          module.l = true;
          // Return the exports of the module
          return module.exports;
        }
        // expose the modules object (__webpack_modules__)
        __webpack_require__.m = modules;
        // expose the module cache
        __webpack_require__.c = installedModules;
        // define getter function for harmony exports
        __webpack_require__.d = function(exports, name, getter) {
          if(!__webpack_require__.o(exports, name)) {
            Object.defineProperty(
              exports,
              name,
              { enumerable: true, get: getter }
            );
          }
        };
        // define __esModule on exports
        __webpack_require__.r = function(exports) {
          if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
          }
          Object.defineProperty(exports, '__esModule', { value: true });
        };
        // create a fake namespace object
        // mode & 1: value is a module id, require it
        // mode & 2: merge all properties of value into the ns
        // mode & 4: return value when already ns object
        // mode & 8|1: behave like require
        __webpack_require__.t = function(value, mode) {
          if(mode & 1) value = __webpack_require__(value);
          if(mode & 8) return value;
          if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
          var ns = Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, 'default', { enumerable: true, value: value });
          if(mode & 2 && typeof value != 'string')
            for(var key in value)
              __webpack_require__.d(ns, key, function(key) {
                return value[key];
              }.bind(null, key));
          return ns;
        };
        // getDefaultExport function for compatibility with non-harmony modules
        __webpack_require__.n = function(module) {
          var getter = module && module.__esModule ?
            function getDefault() { return module['default']; } :
            function getModuleExports() { return module; };
          __webpack_require__.d(getter, 'a', getter);
          return getter;
        };
        // Object.prototype.hasOwnProperty.call
        __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        // __webpack_public_path__
        __webpack_require__.p = "";
        // Load entry module and return exports
        return __webpack_require__(__webpack_require__.s = "./dom.js");
      })
      /************************************************************************/
      ({

      /***/ "./dom.js":
      /*!****************!*\
        !*** ./dom.js ***!
        \****************/
      /*! no static exports found */
      /***/ (function(module, exports, __webpack_require__) {

      eval(`
        var getUsers = __webpack_require__(/*! ./users */ \"./users.js\").getUsers\n\n
        function addUserToDOM(name) {\n
          const node = document.createElement(\"li\")\n
          const text = document.createTextNode(name)\n
          node.appendChild(text)\n\n
          document.getElementById(\"users\")\n
            .appendChild(node)\n}\n\n
          document.getElementById(\"submit\")\n
            .addEventListener(\"click\", function() {\n
              var input = document.getElementById(\"input\")\n
              addUserToDOM(input.value)\n\n
              input.value = \"\"\n})\n\n
              var users = getUsers()\n
              for (var i = 0; i < users.length; i++) {\n
                addUserToDOM(users[i])\n
              }\n\n\n//# sourceURL=webpack:///./dom.js?`
      );}),

      /***/ "./users.js":
      /*!******************!*\
        !*** ./users.js ***!
        \******************/
      /*! no static exports found */
      /***/ (function(module, exports) {

      eval(`
        var users = [\"Tyler\", \"Sarah\", \"Dan\"]\n\n
        function getUsers() {\n
          return users\n}\n\nmodule.exports = {\n
            getUsers: getUsers\n
          }\n\n//# sourceURL=webpack:///./users.js?`);})
      });
    #+end_src
    To get a better understanding, read the comments in the output above.

    The biggest takeaway for the above snippet, aside from integrating all of our code together into
    one output, is that the entire snippet is *one big IIFE*.

*** ES Modules

    So TC-39 finally resolved to designing a builtin JS module system, and it improves on our IIFE
    and CommonJS style system by:
    - making it async by default
    - adding explicitly new keywords, =import= and =export=, instead of a helper function =require= and
      respecting norms around the usage of =module= identifiers

      
    take the following example =util.js= file:
    #+begin_src js
      // utils.js

      // Not exported
      function once(fn, context) {
        var result
        return function() {
          if(fn) {
            result = fn.apply(context || this, arguments)
            fn = null
          }
          return result
        }
      }

      // Exported
      export function first (arr) {
        return arr[0]
      }

      // Exported
      export function last (arr) {
        return arr[arr.length - 1]
      }
    #+end_src

    every exported function is prepended with the =export= keyword.

    there are a few options for *importing* es modules.

    1. importing everything
       #+begin_src js
         import * as utils from './utils'

         utils.first([1,2,3]) // 1
         utils.last([1,2,3]) // 3
       #+end_src

    2. *named imports*
       #+begin_src js
         import { first } from './utils'

         first([1,2,3]) // 1
       #+end_src

    3. (if available) *default imports*
       with es modules, you can define a *default* export.
       #+begin_src js
         // leftpad.js

         export default function leftpad (str, len, ch) {
           var pad = '';
           while (true) {
             if (len & 1) pad += ch;
             len >>= 1;
             else break;
           }
           return pad + str;
         }

         // app.js
         import leftpad from './leftpad'
       #+end_src

       these =default= imports can be mixed with normal exports as well:
       #+begin_src js
         import leftpad, { first, last } from './utils'
       #+end_src


    returning to our original example, we can leverage ES modules as so:
    #+begin_src js
      // users.js

      var users = ["odb", "rza", "gza"]

      export default function getUsers() {
        return users
      }

      // dom.js

      import getUsers from './users.js'

      function addUserToDOM(name) {
        const node = document.createElement("li")
        const text = document.createTextNode(name)
        node.appendChild(text)

        document.getElementById("users")
          .appendChild(node)
      }

      document.getElementById("submit")
        .addEventListener("click", function() {
          var input = document.getElementById("input")
          addUserToDOM(input.value)

          input.value = ""
      })

      var users = getUsers()
      for (var i = 0; i < users.length; i++) {
        addUserToDOM(users[i])
      }
    #+end_src

    *ES modules are native to js and thus browsers support them without a bundler*. unlike the plain
     IIFE pattern, we don't need to worry about ordering and sourcing several JS files in our
     html. Furthermore, unlike CommonJS, we don't need a bundler to make the browser understand our
     modules. /Furthermore/, all we need to do is source the major/primary js module and add
     ~type='module'~ attribute to the script tag:
     #+begin_src js
       <!DOCTYPE html>
       <html>
         <head>
           <title>Users</title>
         </head>

         <body>
           <h1>Users</h1>
           <ul id="users">
           </ul>
           <input id="input" type="text" placeholder="New User"></input>
           <button id="submit">Submit</button>

           <script type=module src='dom.js'></script>  </body>
       </html>     
     #+end_src

*** tree shaking
    another aspect of ES modules is that they are *static* and are *required to be declared at the top
    of the module*. With CommonJS style modules, you can =require= a module anywhere and can therefore
    even conditionally import module code:
    #+begin_src js
      if (pastTheFold === true) {
          require('./foo')
      }
    #+end_src
    the same is invalid for ES modules (though there is a stage 3 proposal for a similar feature).

    the benefit to static modules is that it allows for static analysis and optimization of imports
    via *tree shaking*, which is just dropping dead/unused code from your import bundle.

** lecture 13
*** Class Fields
   as of now, field variables of a class in ES6 are declared in the constructor:
   #+begin_src js
     constructor() {
         this.foo = 0
         this.bar = "bar"
         /* etc */
     }
   #+end_src

   however, there is a stage 3 proposal in TC-39 for *declaring class fields* (properties) directly
   onto a class as opposed to needing their declaration and instatiation within the constructor:
   #+begin_src js
     class Foo extends Bar {
         foo = 0
         bar = "bar"
         someClassMethod() {
             // whatever
         }
         /* rest of class */
     }
   #+end_src

   this is nice and all, but really benefits react code. here's a typical react component:
   #+begin_src js
     class PlayerInput extends Component {
       constructor(props) {
         super(props)
         this.state = {
           username: ''
         }

         this.handleChange = this.handleChange.bind(this)
       }
       handleChange(event) {
         this.setState({
           username: event.target.value
         })
       }
       render() {
         ...
       }
     }

     PlayerInput.propTypes = {
       id: PropTypes.string.isRequired,
       label: PropTypes.string.isRequired,
       onSubmit: PropTypes.func.isRequired,
     }

     PlayerInput.defaultProps = {
       label: 'Username',
     }
   #+end_src

   now here's the same component using the class fields declaration, starting with moving =state= out:
   #+begin_src js
     class PlayerInput extends Component {
       state = {
         username: ''
       }
       constructor(props) {
         super(props)

         this.handleChange = this.handleChange.bind(this)
       }
       handleChange(event) {
         this.setState({
           username: event.target.value
         })
       }
       render() {
           /* snip */
       }
     }

     PlayerInput.propTypes = {
       id: PropTypes.string.isRequired,
       label: PropTypes.string.isRequired,
       onSubmit: PropTypes.func.isRequired,
     }

     PlayerInput.defaultProps = {
       label: 'Username',
     }
   #+end_src

   what is annoying is that we still need to add the properties =propTypes= and =defaultProps= after the
   declaration of =PlayerInput= because of the limits on =static= usage, i.e. only methods and not
   values can be made static.

   luckily, the Class Fields proposal includes this functionality!
   #+begin_src js
     class PlayerInput extends Component {
       static propTypes = {
         id: PropTypes.string.isRequired,
         label: PropTypes.string.isRequired,
         onSubmit: PropTypes.func.isRequired,
       }
       static defaultProps = {
         label: 'Username'
       }
       state = {
         username: ''
       }
       constructor(props) {
         super(props)

         this.handleChange = this.handleChange.bind(this)
       }
       handleChange(event) {
         this.setState({
           username: event.target.value
         })
       }
       render() {
         /* ... */
       }
     }
   #+end_src

   awesome, now all we have left is an ugly constructor method that does nearly nothing. all it does
   is call =super()= and attach =this= to the instance object to ensure proper context for our call to =handleChange=.

   ... what if we just use an arrow function for =handleChange= then?

   #+begin_src js
     class PlayerInput extends Component {
       static propTypes = {
         id: PropTypes.string.isRequired,
         label: PropTypes.string.isRequired,
         onSubmit: PropTypes.func.isRequired,
       }
       static defaultProps = {
         label: 'Username'
       }
       state = {
         username: ''
       }
       handleChange = (event) => {
         this.setState({
           username: event.target.value
         })
       }
       render() {
         /* ... */
       }
     }
   #+end_src

*** downsides of class fields
    
    recall that =class= is just syntactic sugar over the psuedo-classical pattern of attaching shared
    methods to an object type's prototype (it's constructing function's prototype). this is
    performant because they are not dynamic, i.e. each instance does not re-create the function
    method. the issue with class fields is, by definition, they are defined on the class
    instantiation. there is overhead with this and so, maybe for larger and commonly used components
    of a project, can be a significant performance cost.

    for example, if we used an arrow function to make =sleep= a class field in =Animal=:
    #+begin_src js
      class Animal {
        eat() {}
        sleep = () => {}
      }

      // Is equivalent to

      function Animal () {
        this.sleep = function () {}
      }

      Animal.prototype.eat = function () {}
    #+end_src

*** private fields

    historically js had no notion of private fields because there is no real mechanism to prevent
    consuming code to access it, so an underscore that prefixed a variable name was a signal to
    "please not use this variable and treat it as private". again, not enforceable though.
    #+begin_src js
      class Car {
        _milesDriven = 0
        drive(distance) {
          this._milesDriven += distance
        }
        getMilesDriven() {
          return this._milesDriven
        }
      }

      const tesla = new Car()
      tesla.drive(10)
      console.log(tesla._milesDriven) // returns 10, completely valid despite being "private"
    #+end_src

    The Class Field proposal now also formalizes actual *private fields* via the =#= symbol:
    #+begin_src js
      class Car {
        #milesDriven = 0
        drive(distance) {
          #milesDriven += distance
        }
        getMilesDriven() {
          return #milesDriven
        }
      }

      const tesla = new Car()
      tesla.drive(10)
      tesla.getMilesDriven() // 10
      tesla.#milesDriven // Invalid
    #+end_src


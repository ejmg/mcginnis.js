* toc                                                                :TOC_3:
- [[#modern-js][modern js]]
  - [[#lecture-1][lecture 1]]
  - [[#lecture-2][lecture 2]]
    - [[#variable-declarations-vs-initializations][variable declarations vs initializations]]
    - [[#hoisting][hoisting]]
    - [[#var-vs-let-vs-const][​=var= vs =let= vs =const=]]
  - [[#lecture-3][lecture 3]]
    - [[#dot-notation-and-object-literals][dot notation and object literals]]
    - [[#object-destructuring][object destructuring]]
    - [[#advanced-features-of-destructuring][advanced features of destructuring]]
  - [[#lecture-4][lecture 4]]
    - [[#shorthand-properties][shorthand properties]]
    - [[#shorthand-method][shorthand method]]
  - [[#lecture-5][lecture 5]]
    - [[#computed-views][computed views]]
  - [[#lecture-6][lecture 6]]
    - [[#template-literals][template literals]]
  - [[#lecture-7][lecture 7]]
    - [[#arrow-functions][arrow functions]]
    - [[#managing-this-with-arrow-functions][managing =this= with arrow functions]]
    - [[#nice-to-knows-about-arrow-functions]["nice to knows" about arrow functions]]
  - [[#lecture-8][lecture 8]]
    - [[#default-params][default params]]
    - [[#required-arguments]["required" arguments]]
  - [[#lecture-9][lecture 9]]
    - [[#compiling-vs-polyfills-with-babel][compiling vs Polyfills with Babel]]
  - [[#lecture-10][lecture 10]]
    - [[#callbacks][callbacks]]
    - [[#darkside-of-callbacks][darkside of callbacks]]
    - [[#promises][Promises]]
    - [[#chaining][chaining]]
    - [[#resolve][resolve]]
    - [[#improvements-to-chaining-and-resolve][improvements to chaining and resolve]]
    - [[#error-handling][error handling]]
  - [[#lecture-11][lecture 11]]
    - [[#objects][objects]]
    - [[#functional-instantiation][functional instantiation]]
    - [[#functional-instantiation-with-shared-methods][Functional Instantiation with Shared Methods]]
    - [[#objectcreate][Object.create]]
    - [[#functional-instatiation-with-shared-methods-and-objectcreate][Functional Instatiation with Shared Methods and Object.create]]
    - [[#prototypal-instantiation][Prototypal Instantiation]]
    - [[#psuedo-classical-instantiation][psuedo-classical instantiation]]
    - [[#classes][classes]]
    - [[#array-methods][array methods]]
    - [[#static-methods][static methods]]
    - [[#getting-the-prototype-of-an-object][getting the prototype of an object]]
    - [[#determining-if-a-property-lives-on-a-prototype][determining if a property lives on a prototype]]
    - [[#check-if-object-is-an-instance-of-class][check if object is an instance of class]]
    - [[#creating-new-agnostic-constructor-functions][creating new agnostic constructor functions]]
    - [[#recreating-the-objectcreate-method][recreating the =Object.create()= method]]
    - [[#arrow-functions-1][arrow functions]]
  - [[#lecture-12][lecture 12]]
    - [[#why-modules][why modules]]
    - [[#js-modules][js modules]]
    - [[#js-modules-from-the-ground-up][js modules from the ground up]]
    - [[#immediately-invoked-function-expressions-iife][Immediately Invoked Function Expressions (IIFE)]]
    - [[#module-exports][module exports]]
    - [[#defining-our-module-api][defining our module api]]
    - [[#module-bundlers][Module Bundlers]]
    - [[#es-modules][ES Modules]]
    - [[#tree-shaking][tree shaking]]
  - [[#lecture-13][lecture 13]]
    - [[#class-fields][Class Fields]]
    - [[#downsides-of-class-fields][downsides of class fields]]
    - [[#private-fields][private fields]]
- [[#react][react]]
  - [[#overview][overview]]
    - [[#why-react][why react]]
    - [[#the-react-ecosystem][the react ecosystem]]
  - [[#road-to-hello-world][road to hello world]]
    - [[#modules-cdns-and-script-tags][modules, CDNs, and script tags]]
    - [[#npm][npm]]
    - [[#webpack][webpack]]
    - [[#react-elements-vs-components][react elements vs components]]
    - [[#jsx-for-beginners][JSX for beginners]]
  - [[#passing-data-to-components][passing data to components]]
    - [[#intro-to-props][intro to props]]
    - [[#props-practice][props practice]]
  - [[#rendering-lists][rendering lists]]
    - [[#lists-in-react][lists in react]]

* modern js
** lecture 1
** lecture 2
*** variable declarations vs initializations
    - declare just declares the variable
      + =var foo;= declares foo
      + =undefined= by default
    - initialization gives the first variable to the variable
      + =var foo = "nice"=, foo is initialized to a string value


    - Scope: defines where functions and variables are accessible in your program
      + two types in JS
        1. Function: if a variable statement occurs inside a function declaration, the variables are
           defined with function-level scope in that function, otherwise...
        2. Global: variables are created as members of the *global object*, that is, they are given
           global scope, when they are not declared inside a function


    McGinnis kind of confuses me here because he states the implication of these scopes is
    contextual to the usage of =var=. That is, a variable declared with =var= in a function has Function
    level scope but a variable "declared without =var=" is created as a property on the global
    function. So is this also a result of the semantics of =var=? I guess? /shrug/

    
    #+CAPTION: basic example of var and function scope
    #+begin_src js
      // gets us an unformatted date string
      function getDate() {
          // date is only accessible here within function scope, no shit
          var date = new Date();
          return date;
      }
      // works just fine
      console.log(getDate());

      // will return reference error
      // console.log(date);

      // gets us a formatted date string
      function getDate() {
          var date = new Date();
          function formatDate() {
              // Function scope means inner functions have a lexical bind to `date`
              // date until re-defined.
              return date.toDateString().slice(4);
          }
          return formatDate();
      }

      // Pretty date string
      console.log(getDate());
    #+end_src

    #+CAPTION: more complicated example of scope
    #+begin_src js
      function discount_prices(prices, discount) {
          var discounted = [];
          for (var i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // we still have access to each variable in this function declaration.
          // javascript is... really good, actually
          console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }

      discount_prices([100, 200, 300], .5)
      // can't refer to the variables just printed out to console
      // directly, however...
      // console.log(final_price); // error
    #+end_src

*** hoisting
    *Hoisting*: when the Javascript interpreter evals your code, it moves all functions and variable
    declarations at the "top" of the current scope.


    I think this is kinda of what Haskell does more or less, as this:

    #+begin_src js
      console.log(foo); // output: undefined
      var foo;
    #+end_src
    
    ...before execution becomes this:
    
    #+begin_src js
      var foo;
      console.log(foo) // output: undefined
    #+end_src

    Taking the =discount_prices= example, it becomes the following:

    #+begin_src js
      function discount_prices(prices, discount) {
          var discounted;
          var i;
          var discount_prices;
          var final_price;
          var discounted = [];
          for (var i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // we still have access to each variable in this function declaration.
          // javascript is... really good, actually
          console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }
    #+end_src

**** hoisting and =var=

     The reason why =var= is a matter of concern with respect to function scope is that if a variable
     were to be declared without =var=, then the JS interpreter will continue looking "outwards" from
     the function scope until it reaches the global scope. When no such declaration is found, the JS
     interpreter will declare that variable as a property of the global scope. /Nice! Great language!/

     Don't actually do this!

*** ​=var= vs =let= vs =const=

    The main differences: between =var= and =let=:
    - =let=
      + block scoped, not function scoped
        * it is available within the set of statements between the ={}='s you declared it within
        * this is more like sane languages with sane scoping defaults
      + =ReferenceError= when accessing a variable before it's declared
    - =var=
      + function scoped
        * Available throughout the entire function it is declared within
      + =undefined= returned when accessing a variable before it's declared
        
    Recall the =i= counter variable from the last example. If you declare it with =let=, the console
    statement for it no longer works. =ReferenceError= will be returned. Similarly, if you were to try
    to console.log() a variable before it gets assigned a value, like =discounted=, it would also
    return a =ReferenceError= instead of =undefined= if it were declared with =var=.

    #+begin_src js
      function discount_prices(prices, discount) {
          // returns error if attempted:
          // console.log(discounted)
    
          // this still works, though, because discounted_price is decl with var
          console.log(discounted_price); // returns undefined
          let discounted = [];
          for (let i = 0; i < prices.length; i++) {
              var discounted_price = prices[i] * (1 - discount);
              var final_price = Math.round(discounted_price * 100) / 100;
              discounted.push(final_price);
          }
          // No longer will work, will throw error.
          // console.log(i);
          console.log(discounted_price);
          console.log(final_price);
          return discounted;
      }

      discount_prices([100, 200, 300], .5)
    #+end_src

    The only real difference between =let= and =const= is that =const= assignments are immutable and you
    must declare the variable (i.e., you cannot initialize without a value). 

    #+begin_src js
      // Error!
      // const foo;
      const foo = "foo";
      // Error!
      // foo = "bar";
      let bar = "bar";
      bar = "foo";
      var buz = "buz";
      buz = "fizz";
    #+end_src

    =const='s immutability is not perfect, however:

    #+begin_src js
      const person = {
        name: 'Kim Kardashian'
      }

      person.name = 'Kim Kardashian West' // totally legal. 

      // person = {} // Error!
    #+end_src

    Reassigning the field is legal because the =const= declaration is on the object itself, not every
    field. Changing the value of the field is not taken as reassignment, whereas attempting to
    reassign =person= itself to ={}= is taken as illegal for that exact reason.

    *try to always use const.*

** lecture 3
*** dot notation and object literals

    to add something to a js object, *dot notation* works just fine. you can similarly access the
    fields using dot notation.

    #+begin_src js
      const user = {};
      user.name = 'elias'
      user.handle = 'don\'t have one because twitter deleted me for no reason';
      user.location = 'westport';

      const name = user.name;
      const local = user.location;
    #+end_src

    to add multiple fields at once, use javascript's *object literal notation*.

    #+begin_src js
      const user = {
          name: 'elias',
          handle: 'lol',
          location: 'westport',
      };

      const name = user.name;
    #+end_src
*** object destructuring
    *object destructuring* is effectively the opposite of object literal notation, i.e. "allows you to
    extract multiple properties from an object". introduced by ES2015. drastically reduces
    boilerplate.

    this:
    #+begin_src js
      const name = user.name;
      const handle = user.handle;
      const local = user.location;
      // ... and so on
    #+end_src

    becomes:
    #+begin_src js
      const { name, handle, location } = user;
    #+end_src

    note that the variables destructuring the object *must have the same name* using plain
    destructuring, i.e. =local= won't be defined in this statement:
    #+begin_src js
      const { name, handle, local} = user;
    #+end_src

    Destructuring semantics /apply to functions/ as well:

    #+begin_src js
      function getUser() {
          return {
              name: 'elias',
              handle: 'lol',
              location: 'westport',
          }
      }

      const { name, handle, location } = getUser();
    #+end_src

    can also use destructuring on arrays. presumably this is useful in combination with nested json
    structures? idk, not complaining.

    #+begin_src js
      const user = ['elias', 'lol', 'westport'];
      const [ name, handle, local ] = user;
    #+end_src

*** advanced features of destructuring

    What if you want the variable name to be different than the field?

    #+begin_src js
      const user = {
          n: 'smalls',
          h: '@biggiesmols',
          l: 'westport',
      };
    #+end_src

    to destructure the following object with better identifier names, assign them on the right using
    syntax similar to object literal notation:

    #+begin_src js
      const {n: name, h: handle, l: location } = user;
    #+end_src

    looks useless? happens all the time. here's what the =Link= component for React Router Native
    looks like:

    #+begin_src js
      render () {
        // Note, component gets renamed to Component with capital C
        const { component: Component, to , replace, ...rest } = this.props
        return <Component {...rest} onPress={this.handlePress}/>
      }
    #+end_src

    
**** object destructuring on function arguments and params

     We have the following function for interacting with GitHub's api:
     #+begin_src js
       function fetchRepos (language, minStars, maxStars, createdBefore, createAfter) {
           // api logic
       }
     #+end_src

     two problems introduced by this function:
     1. need to remember order of arguments
     2. need to remember/know what each arg is for and how we pass it in, i.e. form, type

        
     one solution is just to yeet in what we know and make the rest nulls:

     #+begin_src js
       fetchRepos('JavaScript', 100, null, new Date('01.01.2017').getTime(), null);
     #+end_src

     ... /or we could use destructuring to solve these problems/.
     
     #+begin_src js
       fetchRepos({
           language: 'JavaScript',
           maxStars: null,
           createdAfter: null,
           createdBefore: new Date('01/01/2017').getTime(),
           minStars: 100,
       });
     #+end_src

     by using object destructuring, we remove the order of params as an issue. The arguments are
     passed in by name with reference to the param's field names.

     to solve the issue of argument types, we can use *default values* for all properties to ensure
     all are given something that will work (otherwise, we have no clue if a value like =null= will be
     accepted, work as intended). One ways to do this is by re-declaring the variables within the
     function body to accept either the passed value or, if =undefined=, instead pass a different value:

     #+begin_src js
       function fetchRepos ({ language, minStars, maxStars, createdBefore, createAfter }) {
         language = language || 'All';
         minStars = minStars || 0;
         maxStars = maxStars || '';
         createdBefore = createdBefore || '';
         createdAfter = createdAfter || '';
       }
     #+end_src

     This is kinda ugly, though. /Object destructuring allows default values, however/, which yields a
     much cleaner function signature:

     #+begin_src js
       function fetchRepos({ language='All', minStars=0, maxStars='', createdBefore='', createdAfter='' }) {
           // api logic
           console.log(language);
           console.log(minStars);
           console.log(maxStars);
           console.log(createdBefore);
           console.log(createdAfter);
       }
     #+end_src

     Now our api call becomes the much cleaner statement:
     #+begin_src js
       fetchRepos({
         language: 'JavaScript',
         createdBefore: new Date('01/01/2017').getTime(),
         minStars: 100,
       });
       // prints to console:
       // "JavaScript"
       // 100
       // 
       // 1483250400000
       // 
     #+end_src

**** array destructuring and function params

     Can do the same with arrays with respect to function params. Have the following function:
     #+begin_src js
       function getUserData (player) {
         // note that we wrap our function calls in an array here
         return Promise.all([
           getProfile(player),
           getRepos(player)
         ]).then(function (data) {
           // extract array vals
           const profile = data[0];
           const repos = data[1];

           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

     Side note: the above function uses *Promise*'s with calls to =getProfile= and =getRepos=, which are
     async functions. Once those promises /resolve/, we pass a function to =.then()=, which handles the
     results of the promise.

     inside of =.then()=, we declare a function that takes a param =data=, which will be an array that
     has indices. The first is the user's profile, the second is their repos. /Order matters here/
     because it's an array and because of the order of the calls we made to the functions returning
     promises.

     To take advantage of the array structure, we can destructure the values returned by our
     promises so don't need to extract them manually:

     #+begin_src js
       function getUserData (player) {
         return Promise.all([
           getProfile(player),
           getRepos(player)
         ]).then(function (data) {
           // we destructure the values of data here
           const [ profile, repos ] = data
           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

     One final improvement is, just like with objects, is to move the restructuring directly into
     the params of the function (passed to =.then()=) itself:
     
     #+begin_src js
       function getUserData (player) {
         return Promise.all([
           getProfile(player),
           getRepos(player)
           // yeet, clean code
         ]).then(([ profile, repos ]) => {
           return {
             profile: profile,
             repos: repos
           }
         })
       }
     #+end_src

** lecture 4
*** shorthand properties

    *shorthand property*: whenever you have a variable that matches the name of a property on an
    object, you can omit the property name when constructing an instance of that object.

    the following:
    #+begin_src js
      function formatMessage (name, id, avatar) {
          return {
              name: name,
              id: id,    
              avatar: avatar,    
              timestamp: Date.now()
          }
      }
    #+end_src

    can be shortened to:
    #+begin_src js
      function formatMessage (name, id, avatar) {
          return {
              name,    
              id,    
              avatar,    
              timestamp: Date.now()
          }
      }
    #+end_src
*** shorthand method
    *shorthand method names*: when a function is a property on an object, that makes it a *method*. As
     of ES6, when constructing an object that has a function as a field you can now omit the
     =function= keyword entirely.

     The following:
     #+begin_src js
       function formatMessage (name, id, avatar) {
           return {
               name,
               id,
               avatar,
               timestamp: Date.now(),
               save: function () {
                   // save message    
               }  
           }
       }
     #+end_src

     can become:
     #+begin_src js
       function formatMessage (name, id, avatar) {
           return {
               name,
               id,
               avatar,
               timestamp: Date.now(),
               // wow i saved like 8 whole keystrokes wow lol
               save () {
                   // save message    
               }  
           }
       }     
     #+end_src
** lecture 5
*** computed views
    *computed property names*: as of ES6, you can have expressions that get evaluated as properties on
    an object.

    Say you have a function that takes a (=key=, =value=) pair and returns an object that maps =key= as a
    property with =value= as its value:

    #+begin_src js
      function objectify (key, value) {
          let obj = {}
          obj[key] = value
          return obj
      }

      objectify('name', 'elias') // { name: 'elias' }
    #+end_src

    Now with computed property names you can do this:
    #+begin_src js
      function objectify (key, value) {
          return {
              [key]: value
          }
      }    
    #+end_src

    The =[]= are critical to the behavior of this feature. Note how the following function behaves:
    #+begin_src js
      function confusing_var_names(bar, bat) {
          return {
              [bar]: bat,
              is: 'forever'
          }
      }

      confusing_var_names('wu', 'tang') // returns { wu: 'tang', is: 'forever' }
    #+end_src
** lecture 6
*** template literals
    In the olden days, when you wanted to return a formatted strings with a bunch of variables
    injected into it, you had to do horrid shit like this:
    #+begin_src js
      function makeGreetingTemplate (name, email, id) {
          return '<div>' +
              '<h1>Hello, ' + name + '.</h1>' +
              '<p>We\'ve emailed you at ' + email + '. ' +
              'Your user id is "' + id + '".</p>' +
              '</div>'
      }
    #+end_src

    With *template literals*, instead of worrying about escaping all special characters and
    concatenating a bunch of strings together, you instead wrap the string with =``='s instead of
    ~""~s or ~''~s. Any expression you wish to inject into the template is surrounded by =${/* expr
    here */}=.

    Now look at the same function with template literals:

    #+begin_src js
      function makeGreetingTemplate (name, email, id) {
          return `
          <div>
            <h1>Hello, ${name}</h1>
            <p>
              We've email you at ${email}.
              Your user id is "${id}".
            </p>
          </div>
        `
      }
    #+end_src
** lecture 7
*** arrow functions
    *arrow functions* allow for more succinct code and better management over the semantics of the
    =this= keyword.

    refresh on basic structure/syntax of function declarations:

    #+begin_src js
      // function declaration
      function add (x,y) {
          return x + y;
      }

      // function expr
      const add = function (x,y) {
          return x + y;
      }
    #+end_src

    now the above function as an arrow function:
    #+begin_src js
      const add = (x,y) => {
          return x + y;
      }
    #+end_src

**** example of reducing boilerplate

     here's a shitty api function that returns a given user's tweets with > 50 faves /and/ retweets:
     #+begin_src js
       function getTweets (uid) {
         return fetch('https://api.users.com/' + uid)
           .then(function (response) {
             return response.json()
           })
           .then(function (response) {
             return response.data
           }).then(function (tweets) {
             return tweets.filter(function (tweet) {
               return tweet.stars > 50
             })
           }).then(function (tweets) {
             return tweets.filter(function (tweet) {
               return tweet.rts > 50
             })
           })
       }
     #+end_src

     note the boilerplate introduced by having to explicitly declare =function= for each anonymous
     function being passed to each =.then()= call that operates over the data returned. arrow
     functions can help remove such boilerplate which makes for a modest improvement:
     #+begin_src js
       function getTweets (uid) {
           return fetch('https://api.users.com/' + uid)
                // look ma, no function keyword
               .then((response) => {
                   return response.json()
               })
               .then((response) => {
                   return response.data
               }).then((tweets) => {
                   return tweets.filter((tweet) => {
                       return tweet.stars > 50
                   })
               }).then((tweets) => {
                   return tweets.filter((tweet) => {
                       return tweet.rts > 50
                   })
               })
       }
     #+end_src

**** implicit returns with arrow functions

     but wait! we can reduce the boilerplate even more!
     
     with arrow functions, if your function is a one-liner ("concise body"), then you can use the
     notion of *implicit returns*, which allow the omitting of the =return= keyword.

     so something like =add= can be transformed as such:
     #+begin_src js
       // old, tired
       function add(x,y) {
           return x + y;
       }
       // new, wired
       const add = (x,y) => x + y;
     #+end_src
    
     now the tweet example can be further improved as such:
     #+begin_src js
       // aight this is legit better
       function getTweets (uid) {
         return fetch('https://api.users.com/' + uid)
           .then((response) => response.json())
           .then((response) => response.data)
           .then((tweets) => tweets.filter((tweet) => tweet.stars > 50))
           .then((tweets) => tweets.filter((tweet) => tweet.rts > 50))
       }
     #+end_src

     /furthermore/, *if the arrow function only has one param, then you can drop the parentheses
     around it entirely*:
     #+begin_src js
       // NICE
       function getTweets (uid) {
         return fetch('https://api.users.com/' + uid)
           .then(response => response.json())
           .then(response => response.data)
           .then(tweets => tweets.filter((tweet) => tweet.stars > 50))
           .then(tweets => tweets.filter((tweet) => tweet.rts > 50))
       }     
     #+end_src

     [[https://thumbs.gfycat.com/ZigzagDistinctBoilweevil-max-1mb.gif]]

*** managing =this= with arrow functions
    
    arrow functions help manage the semantics of =this= because they don't *create their own context*.

    Here's a blob of react code that I don't understand/have any clue what it does:
    #+begin_src js
      class Popular extends React.Component {
          constructor(props) {
              super();
              this.state = {
                  repos: null,
              };

              this.updateLanguage = this.updateLanguage.bind(this);
          }
          componentDidMount () {
              this.updateLanguage('javascript')
          }
          updateLanguage(lang) {
              api.fetchPopularRepos(lang)
                  .then(function (repos) {
                      this.setState(function () {
                          return {
                              repos: repos
                          }
                      });
                  });
          }
          render() {
              // Stuff
          }
      }
    #+end_src

    /it doesn't work lol/. why? because it doesn't bind =this= correctly. apparently this is how you
    would fix this using ES5:

    #+begin_src js
      class Popular extends React.Component {
          constructor(props) {
              super();
              this.state = {
                  repos: null,
              };

              this.updateLanguage = this.updateLanguage.bind(this);
          }
          componentDidMount () {
              this.updateLanguage('javascript')
          }
          updateLanguage(lang) {
              api.fetchPopularRepos(lang)
                  .then(function (repos) {
                      this.setState(function () {
                          return {
                              repos: repos
                          }
                      });
                    // lol this is the fix. incredible.
                  }.bind(this)); 
          }
          render() {
              // Stuff
          }
      }
    #+end_src

    apparently people actually put up with that bullshit for like.... years. anyway, arrow functions
    make that go away. fixing the =updateLanguage= method reduces both boilerplate, makes it more
    readable, and easier to reason about because of better =this= ergonomics.

    #+begin_src js
      updateLanguage(lang) {
        api.fetchPopularRepos(lang)
          .then((repos) => {
            this.setState(() => {
              return {
                repos: repos
              }
            });
          });
      }
    #+end_src

*** "nice to knows" about arrow functions
**** differentiating function bodies and implicit returns

     say we want to optimize =updateLanguage= more by using an implicit return on the object we
     return from the nested =.then()= call.

     #+begin_src js
       api.fetchPopularRepos(lang)
           .then((repos) => {
               this.setState(() => {
                   // no more return statement
                   repos: repos
               });
           });
     #+end_src

     *problem*: this is indistinguishable from declaring a function body vs an implicit return from
     the perspective of the js interpreter. this will error out.
      
     *solution*: wrap implicit return in =()=.

     #+begin_src js
       api.fetchPopularRepos(lang)
           .then((repos) => {
                                   // here, we wrap the {} with ()
               this.setState(() => ({
                   repos: repos
               })); // note extra closing )
           });
     #+end_src

**** leverage shorthand property and method names with arrow functions

     can further improve the above snippet by dropping the field name entirely since the variable
     and field are named the same. this allows us to also drop the wrapping ={}= and =()='s entirely.

     #+begin_src js
       api.fetchPopularRepos(lang)
           .then((repos) => 
               this.setState(() => repos)
           );
     #+end_src

**** logging inside of arrow functions with implicit returns

     how would you log the state within the component function above? one solution would be to
     return the explicit =return= statement so you can add a console call before it:

     #+begin_src js
       this.setState((nextState) => {
           console.log(nextState)
           return {
               repos: repos
           }
       });
     #+end_src

     it works, but it makes us re-add a bunch of boilerplate just for logging. in classic javascript
     fashion, let's do some really janky shit that works and is seemingly encouraged so we can keep
     our code ""clean"":
     #+begin_src js
       this.setState((nextState) => console.log(nextState) || ({
           repos: repos
       }));
     #+end_src

     ... /nice? i guess?/
     
** lecture 8
*** default params

    traditional approach to setting default values for function arguments was to use =||= to check for
    false-y values like =undefined= and =0=.

    so if we have a function that calculates payment and takes the arguments =price=, =salesTax=, and
    =discount= where only =price= is required, we could define =0.5= and =0= as the default values for the
    latter params respectively:
    #+begin_src js
      function calcPayment(price, salesTax, discount) {
          salesTax = salesTax || 0.5;
          discount = discount || 0;
          // stuff
      }
    #+end_src

    *problem*: what happens when the function consumer passes 0 to =salesTax=? given =0= is taken as
     false-y, that means it will get incorrectly overwritten by the default value! what needs to
     happen instead of checking for false-y values is checking for /undefined/ values.

    #+begin_src js
      function calcPayment(price, salesTax, discount) {
          salesTax = typeof salesTax === 'undefined' ? 0.5 || salesTax;
          discount = typeof discount === 'undefined' ? 0 || discount;
          // stuff
      }    
    #+end_src

    works as intended, but now it's kinda verbose.

    ES6 has *default parameters*, which achieve the desired behavior above but with a cleaner syntax:
    #+begin_src js
      function calcPayment(price, salesTax = 0.5, discount = 0) {
          // stuff
      }
    #+end_src
*** "required" arguments

    what if you want to /enforce/ required arguments by throwing an exception when a function is not
    given one? define a function like so:
    #+begin_src js
      function isRequired(name) {
          throw new Error(`${name} is required`)
      }
    #+end_src

    and now you can simply wrap the required parameter with a default value specifying it's name:
    #+begin_src js
      function calcPayment(price = isRequired('price'), 
                           salesTax = 0.5,
                           discount = 0) {
          // stuff
      }    
    #+end_src

    *nice*. whether this type of defensive programming is "good" or not is on you/your
     team/god/whatever.
** lecture 9
*** compiling vs Polyfills with Babel

    js is constantly changing and being updated which results in the browser ecosystem becoming
    fractured and lagging in terms of feature implementations. there are two things that can be done
    to fix this.

    the first major thing is transpiling your modern js into equivalent js that uses older, more
    widely supported syntax and features. this is traditionally done via Babel. look at the
    following modern example code and its transformation:
    #+begin_src js
      // new, fancy js
      const getProfile = username => {
          return fetch(`https://api.github.com/users/${username}`)
              .then((response) => response.json())
              .then(({ data }) => ({
                  name: data.name,
                  location: data.location,
                  company: data.company,
                  blog: data.blog.includes('https') ? data.blog : null
              }))
              .catch((e) => console.warn(e))
      }

      // transformed js via babel
      var getProfile = function getProfile(username) {
        return fetch('https://api.github.com/users/' + username).then(function (response) {
          return response.json();
        }).then(function (_ref) {
          var data = _ref.data;
          return {
            name: data.name,
            location: data.location,
            company: data.company,
            blog: data.blog.includes('https') ? data.blog : null
          };
        }).catch(function (e) {
          return console.warn(e);
        });
      };
    #+end_src

    this will be guaranteed to work in older browsers by transforming newer ES6 features into js
    that browsers know how to execute.... /almost/.

    notice that the =fetch= and =includes= function calls were not transformed into their "analog"
    equivalents of =indexOf= and =XMLHttpRequest= despite their "newness". why didn't this occur?  babel
    only transforms your newer syntax into older equivalents and *does not handle new javascript
    primitives or properties required for the browser's global namespace*.

    to finish the transformation into functional js that more browsers can use, *Polyfill* is required
    to inject the remaining features and properties to make newer code work.

    there is a long ass list of features that babel specifies as supported or in need of
    polyfilling. rather than reading them, just [[https://babeljs.io/][use their documentation to know when polyfill is needed]]. 
** lecture 10

   not all websites can be static, which means having to cope with things like asynchronously
   handling data and events.
*** callbacks
    
    javascript allows for function composition. a function that takes another function as an
    argument is a *higher order function*. in js land, a function passed to a HO function is a
    *callback function*.

    #+begin_src js
      const add = (x,y) => x + y;
      const addFive = (x, addRef) => addRef(x, 5);
    #+end_src

    there are two popular uses for callback functions:
    1. transforming values via fp patterns like =.map()=
    2. delaying the execution of a function until some time/event occurs

       JQuery stuff is a good example for this:
       #+begin_src js
         $('#button').on('click', () => 
           console.log('ya clicked me'))
       #+end_src

       
    the examples thus far have been synchronous, but the latter case is what async programming
    concerns. instead of delaying a function until some event occurs, /we can delay a function until
    we get the data we need/.

    why use async? otherwise, code like the following results in websites that delay full
    loading/rendering until the query finishes its completion:
    #+begin_src js
      // updateUI and showError are irrelevant.
      // Pretend they do what they sound like.

      const id = 'tylermcginnis'

      $.getJSON({
        url: `https://api.github.com/users/${id}`,
        success: updateUI,
        error: showError,
      })
    #+end_src

    /the UI cannot be updated until we have the user's data/. this is undesirable for user facing
    applications. instead, we can ask our program to execute as normal while waiting for a piece of
    data to finish processing/being requested. if it succeeds, update the UI as necessary. if it
    doesn't, maybe throw an error or otherwise handle the exception as necessary. this is what async
    programming allows us to do.

*** darkside of callbacks

    *callback hell* occurs from the original way of handling async events in js. instead of nice,
     clean, and linear code that "sequentially" handles logic that is, in all reality, asynchronous,
     you get a pyramid of death that requires a lot of mental overhead to solve. take the following
     example:
     #+begin_src js
       // updateUI, showError, and getLocationURL are irrelevant.
       // Pretend they do what they sound like.

       const id = 'tylermcginnis'

       // yikes!
       $("#btn").on("click", () => {
           $.getJSON({
               url: `https://api.github.com/users/${id}`,
               success: (user) => {
                   $.getJSON({
                       url: getLocationURL(user.location.split(',')),
                       success (weather) {
                           updateUI({
                               user,
                               weather: weather.query.results
                           })
                       },
                       error: showError,
                   })
               },
               error: showError
           })
       })
     #+end_src
     
     the above code says the following:
     - don't run the AJAX request until the =btn= element is clicked
     - once clicked, make the first request for the user's github
       + if the request fails, show an error
     - if that request succeeds, invoke =updateUI=
       + otherwise, show an error

         
     this pattern of callback programming is difficult to mentally parse and is error
     prone. modularizing the code can help to some degree, but then introduces a significant amount
     of boilerplate code that makes what is  happening ostensibly harder to understand as the logic
     is now broken between a bunch of smaller code snippets like so:
     #+begin_src js
       function getUser(id, onSuccess, onFailure) {
           $.getJSON({
               url: `https://api.github.com/users/${id}`,
               success: onSuccess,
               error: onFailure
           })
       }

       function getWeather(user, onSuccess, onFailure) {
           $.getJSON({
               url: getLocationURL(user.location.split(',')),
               success: onSuccess,
               error: onFailure,
           })
       }

       $("#btn").on("click", () => {
           getUser("tylermcginnis", (user) => {
               getWeather(user, (weather) => {
                   updateUI({
                       user,
                       weather: weather.query.results
                   })
               }, showError)
           }, showError)
       })
     #+end_src

**** inversion of control

     aside from callback hell, callbacks tend to introduce *inversion of control*. when you hand off
     your callback function to the consuming HO function, you are /assuming/ the receiving program
     will be responsible and /only use the callback when it's supposed to/. you are handing the
     control of your program to another program. with 3rd party libraries, there is a good chance
     the API will result in unintended behavior as the library either intentionally or accidentally
     breaks the logic of the callback.

     #+begin_src js
       function criticalFunction () {
           // It's critical that this function
           // gets called and with the correct
           // arguments.
       }

       thirdPartyLib(criticalFunction)
     #+end_src

     in the above snippet, you have /zero control of whether or how =criticalFunction= is called/

*** Promises

    Rather than giving away /your/ callback to a program and hoping they use it as intended, we can
    make programs /promise/ to do something for /us/.

    A *promise* can be in one of three states:
    - *pending*
    - *fulfilled*
    - *rejected*

      
    *promises* were introduced to reduce the complexity of making async requests.

**** how do you create a promise?

     straightforward: create a =new= instance of a =Promise=:
     #+begin_src js
       const promise = new Promise()
     #+end_src

**** how do you change the status of a promise?

     the =Promise= constructor takes one argument: the callback function. inside of this function you
     do whatever async action/logic you need. in addition to this, the callback will, in turn, be
     given two arguments:
     1. =resolve=: a function that allows you to change the status of the promise to =fulfilled=
     2. =reject=: a function that allows you to change the status of the promise to =rejected=

        
     each will get called in their respective case of success or failure of the promise.

     here's a trivial example that only executes the successful case of =resolve=:
     #+begin_src js
       const promise = new Promise((resolve, reject) => {
           // set to resolve in 2 seconds
           setTimeout(() => {
               resolve()
           }, 2000)
       });

       // check status of promise
       console.log('promise is pending -', promise);

       // wait 2 seconds to check again
       setTimeout(() => {
           console.log('promise should be resolved -', promise)
       }, 2000);
     #+end_src

**** how do you listen for when the status of a promise changes?

     probably the most critical aspect of Promises is what to do with them.

     underneath the hood, =Promises= are plain javascript objects with two methods, which each take a
     function:
     1. *then()*: when the status of the promise is changed to =fulfilled=, the function passed to
        =then()= gets invoked, often on the data returned by the promise.
     2. *catch()*: when the status of the promise is changed to =rejected=, the function passed to
        =catch()= gets invoked. this can handle any error codes, data handled to it or take
        alternative action.

        
     the following code creates two different promises that demonstrate the execution of =then()= and
     =catch()= respectively:
     #+begin_src js
       function onSuccess () {
         console.log('Success!')
       };

       function onError () {
         console.log('💩')
       };

       const promise1 = new Promise((resolve, reject) => {
         setTimeout(() => {
           resolve()
         }, 2000)
       });

       promise1.then(onSuccess);
       promise1.catch(onError);

       const promise2 = new Promise((resolve, reject) => {
         setTimeout(() => {
           reject()
         }, 2000)
       });

       promise2.then(onSuccess);
       promise2.catch(onError);
     #+end_src

     
*** chaining
    both =then()= and =catch()= *return a promise*. this is critical because it then allow us to *chain*
    promises.

    here's a contrived example that shows how we can log a sequence of promises by chaining:
    #+begin_src js
      function getPromise () {
          return new Promise((resolve) => {
              setTimeout(resolve, 2000)
          })
      }

      function logA () {
          console.log('A')
      }

      function logB () {
          console.log('B')
      }

      function logCAndThrow () {
          console.log('C')

          throw new Error()
      }

      function catchError () {
          console.log('Error!')
      }

      getPromise()
          .then(logA) // A
          .then(logB) // B
          .then(logCAndThrow) // C
          .catch(catchError) // Error!
    #+end_src

    *chaining* allows us to use promises in such a way that our code maintains a linear form which
     makes reasoning about asynchronous logic easier.





     returning to the modularized callback hell example, we can now refactor it into legitimately
     clean and straightforward code via =Promise='s and chaining:
     #+begin_src js
       function getUser(id) {
           return new Promise((resolve, reject) => {
               $.getJSON({
                   url: `https://api.github.com/users/${id}`,
                   success: resolve,
                   error: reject
               })
           })
       }

       function getWeather(user) {
           return new Promise((resolve, reject) => {
               $.getJSON({
                   url: getLocationURL(user.location.split(',')),
                   success: resolve,
                   error: reject,
               })
           })
       }

       $("#btn").on("click", () => {
           getUser("tylermcginnis")
               .then(getWeather)
               .then((weather) => {
                   // We need both the user and the weather here.
                   // Right now we just have the weather
                   updateUI() // ????
               })
               .catch(showError)
       })
     #+end_src

     already, this code looks better; however, we still have a problem. inside of our actual JQuery
     call, when we get to the =.then()= call on the results of the =getWeather= promise, we only have
     access to =weather= as a value but need =user= as well. How do we ensure =user= gets passed along the
     promise chain?

*** resolve
    *resolve*: =resolve()= is a function that allows you to pass on any arguments to the next =then()=
    invocation on a chain of promises.

    refactoring =getWeather= to use =resolve()=:
    #+begin_src js
      function getWeather(user) {
          return new Promise((resolve, reject) => {
              $.getJSON({
                  url: getLocationURL(user.location.split(',')),
                  success(weather) {
                      // in our success case, we call resolve() and just
                      // pass what we need to make it into the next .then() call
                      resolve({ user, weather: weather.query.results })
                  },
                  error: reject,
              })
          })
      }
    #+end_src

    Now our JQuery call becomes:
    #+begin_src js
      $("#btn").on("click", () => {
          getUser("tylermcginnis")
              .then(getWeather)
              .then((data) => updateUI(data))
              .catch(showError)
      })
    #+end_src

    much cleaner.

*** improvements to chaining and resolve

    our code is nice, but could we make it nicer? what if we could write it like normal synchronous
    code:
    #+begin_src js
      $("#btn").on("click", () => {
          const user = getUser('tylermcginnis')
          const weather = getWeather(user)

          updateUI({
              user,
              weather,
          })
      })
    #+end_src

    in this situation, we have what looks like /truly synchronous/ code that actually behaves
    asynchronously; however, this would make the js engine kill itself. it's hiding the fact that
    each function invocation within it is returning a promise, and pretending otherwise won't make
    it go away.

    but what if... we could explicitly tell js that we were making an *async* function?
    #+begin_src js
                            // "hey js repl, this arrow function is async, watch out okay?
      $("#btn").on("click", async () => {
          const user = getUser('tylermcginnis')
          const weather = getWeather(user)

          updateUI({
              user,
              weather,
          })
      })
    #+end_src

    alright, but now how does the js interpreter know where in this function call is the async
    behavior that it has to wait on? tell it by using the *await* keyword:
    #+begin_src js
      $("#btn").on("click", async () => {
          const user = await getUser('tylermcginnis')
          const weather = await getWeather(user.location)

          updateUI({
              user,
              weather,
          })
      })
    #+end_src

    *async functions* return promises while *await* halts the execution of an async function until the
    expression following it returns /something/.

*** error handling

    when using async/await, instead of using =catch()= as with non-async/await chaining of promises,
    wrap them in *try/catch* blocks:
    #+begin_src js
      $("#btn").on("click", async () => {
          try {
              const user = await getUser('tylermcginnis')
              const weather = await getWeather(user.location)

              updateUI({
                  user,
                  weather,
              })
          } catch (e) {
              showError(e)
          }
      })
    #+end_src

** lecture 11
*** objects
    *objects* are key/value pairs and are a central structure to js.

    an example of instantiating an object using the standard ={}= and dot notation:
    #+begin_src js
      let animal = {};
      animal.name = "tux";
      animal.energy = 10;

      animal.eat = function (amount) {
          console.log(`${this.name} is eating`);
          this.energy += amount;
      }

      animal.sleep = function(length) {
          console.log(`${this.name} is sleeping`);
          this.energy += length;
      }

      animal.play = function(length) {
          console.log(`${this.name} is playing`);
          this.energy -= length;
      }
    #+end_src

*** functional instantiation
    *Functional Instatiation* is creating a function that acts as a constructor for a type of object.
    
    we can encapsulate the logic above into a general constructor for animal objects as so:
    #+begin_src js
      function Animal (name, energy) {
          let animal = {};
          animal.name = name;
          animal.energy = energy;

          animal.eat = function (amount) {
              console.log(`${this.name} is eating`);
              this.energy += amount;
          }

          animal.sleep = function(length) {
              console.log(`${this.name} is sleeping`);
              this.energy += length;
          }

          animal.play = function(length) {
              console.log(`${this.name} is playing`);
              this.energy -= length;
          }

          return animal
      }
    #+end_src
    
    simple enough, but what are some weaknesses of this approach?
    - each method is dynamic, i.e. is re-created for each call to =Animal()=, when they are generic in
      nature.
      + i.e. we are wasting memory and making each =Animal= object larger than necessary.


    solution?

*** Functional Instantiation with Shared Methods

    *Functional Instatiation with Shared Methods* is when methods shared by different objects are
    defined on a single object type that the sharing objects reference for their own instantiation.

    Taking =Animal= as our example:
    #+begin_src js
      function animalMethods = {
          eat = function (amount) {
              console.log(`${this.name} is eating`);
              this.energy += amount;
          }

          sleep = function(length) {
              console.log(`${this.name} is sleeping`);
              this.energy += length;
          }

          play = function(length) {
              console.log(`${this.name} is playing`);
              this.energy -= length;
          }
      }

      function Animal (name, energy) {
          let animal = {};
          animal.name = name;
          animal.energy = energy;

          // now attach the method reference to our new animal
          animal.eat = animalMethods.eat;
          animal.sleep = animalMethods.sleep;
          animal.play = animalMethods.play;

          return animal
      }
    #+end_src

*** Object.create
    Can further implementation via *Object.create*.

    =Object.create= allows you to create an object which will delegate to another object on failed
    lookups, i.e. whenever a property that does not exist is looked up against an object, the
    delegated object will then be checked for that property.

    example:
    #+begin_src js
      const grandparent = {
          name: 'cato the elder',
          age: 60,
          heritage: 'patrician'
      }

      const grandchild = Object.create(grandparent);
      grandchild.name = 'cato the younger';
      grandchild.age = 20;

      console.log(grandchild.name);
      console.log(grandchild.heritage);
    #+end_src

*** Functional Instatiation with Shared Methods and Object.create

    why does =Object.create= matter here? we can now replace all those spurious field calls with a
    single call to =Object.create= to associate an animal with the shared methods of =animalMethods=

    #+begin_src js
      const animalMethods = {
        eat(amount) {
          console.log(`${this.name} is eating.`)
          this.energy += amount
        },
        sleep(length) {
          console.log(`${this.name} is sleeping.`)
          this.energy += length
        },
        play(length) {
          console.log(`${this.name} is playing.`)
          this.energy -= length
        }
      }

      function Animal (name, energy) {
        // see ma, no hands
        let animal = Object.create(animalMethods)
        animal.name = name
        animal.energy = energy

        return animal
      }
    #+end_src

    nice. /but doesn't it still feel hacky to have a whole separate function type separate from
    =Animals= themselves?/ How can this be avoided? The answer lies in *prototypes*.

    every function in js has a *prototype property* that references an object. the solution for
    =Animal='s then is to put the shared methods, instead of inside a separate function, on the
    prototype of =Animal= itself. Then we can delegate to =Animal.prototype= instead of a separate
    function object. This pattern is called...

*** Prototypal Instantiation
    
    Let's use *prototypal instantiation* on =Animal= to implement its shared functions:
    #+begin_src js
      function Animal (name, energy) {
          let animal = Object.create(Animal.prototype)
          animal.name = name
          animal.energy = energy

          return animal
      }

      Animal.prototype.eat = function (amount) {
          console.log(`${this.name} is eating.`)
          this.energy += amount
      }

      Animal.prototype.sleep = function (length) {
          console.log(`${this.name} is sleeping.`)
          this.energy += length
      }

      Animal.prototype.play = function (length) {
          console.log(`${this.name} is playing.`)
          this.energy -= length
      }
    #+end_src

    every instance of the function =Animal= will now have access to these methods. nice.

*** psuedo-classical instantiation

    why is javascript so lame? why does it not already support the features we created using
    prototypes and shared methods? actually, it does via the =new= keyword. using =new=, we can define a
    constructor function that elides the call to =Object.create= its =return= statement because it does
    this implicitly using =this= as a reference to the new object instantiated.

    in other words, if we used =new= with =Animal=, this is all that would be needed:
    #+begin_src js
      function Animal (name, energy) {
          // elided bc happens implicitly
          // const this = Object.create(Animal.prototype)

          this.name = name
          this.energy = energy
          // same again here
          // return this
      }
    #+end_src

    thus, this will work:
    #+begin_src js
      function Animal (name, energy) {
          this.name = name
          this.energy = energy
      }

      Animal.prototype.eat = function (amount) {
          console.log(`${this.name} is eating.`)
          this.energy += amount
      }

      Animal.prototype.sleep = function (length) {
          console.log(`${this.name} is sleeping.`)
          this.energy += length
      }

      Animal.prototype.play = function (length) {
          console.log(`${this.name} is playing.`)
          this.energy -= length
      }

      const tux = new Animal('tux', 10);
    #+end_src


    if you were to call =Animal= without =new=, the =this= object is never created nor returned.

    #+begin_src js
      const vlad = Animal('vlad', 5);
      console.log(vlad); // undefined
    #+end_src

    the pattern for using =new= and attaching shared methods to the prototype of a function is called
    *pseudo-classical instantiation*

*** classes

    it's kinda funny imo how it took till 2015 for javascript to just make =class= a thing, but
    whatever. anyway, yeah, ES6 implemented =class= as a feature, but *=class= is just syntactic sugar
    for the psuedo-classical instantiation pattern* we learned about above. it's nothing special in
    the end.

    to use =class= syntax for =Animal=:
    #+begin_src js
      class Animal {
          constructor(name, energy) {
              this.name = name
              this.energy = energy
          }
          eat(amount) {
              console.log(`${this.name} is eating.`)
              this.energy += amount
          }
          sleep(length) {
              console.log(`${this.name} is sleeping.`)
              this.energy += length
          }
          play(length) {
              console.log(`${this.name} is playing.`)
              this.energy -= length
          }
      }

      const tux = new Animal('tux', 10);
    #+end_src

*** array methods
    connecting to js classes and prototypes, the methods provided for array
    manipulation/transformation are a result of the same pattern.

    if you evaluate =console.log(Array.prototype)= in the developer console on your browser, you will
    see something like:

    [[file:assets/Screenshot_20200525_131458.png]]

    
    this goes for all Objects in js. whenever if an property gets looked up against an object and it
    doesn't exist, along for each delegated object, then eventually it gets looked up against
    =Object.prototype= itself. this is why all objects have methods like =toString()= and
    =hasOwnProperty()=

*** static methods

    what if an object entity has a method that is unique to that object type (class, function, etc)
    but does not need to be shared across each instance, i.e. each instance can use the same single
    function across each rather than having their own? this is a *static method* by definition, and
    its declared within the =class= declaration like any other function aside from being prefixed with
    the =static= keyword.

    for animal, we might have a method that determines which animal, of all the animals, needs to be
    fed next:
    #+begin_src js
      class Animal {
          /* other methods */
          static nextToEat(animals) {
              const sortedByLeastEnergy = animals.sort((a,b) => {
                  return a.energy - b.energy
              })

              return sortedByLeastEnergy[0].name
          }
      }

      const leo = new Animal('Leo', 7)
      const snoop = new Animal('Snoop', 10)

      console.log(Animal.nextToEat([leo, snoop])) // nice
    #+end_src

    =static= is syntactic sugar just like =class= is and in ES5 would otherwise be implemented as so:
    #+begin_src js
      Animal.nextToEat = function (nextToEat) {
          const sortedByLeastEnergy = animals.sort((a,b) => {
              return a.energy - b.energy
          })

          return sortedByLeastEnergy[0].name
      }
    #+end_src
    where we make the function a property of /the =Animal= function/ rather than its /prototype/

*** getting the prototype of an object

    regardless of how an object was instantiated, you can always get a reference to its =prototype=
    via =.getPrototypeOf()=:
    #+begin_src js
      const tux = new Animal('tux', 10);
      const tux_proto = Object.getPrototypeOf(tux);
      console.log(tux_proto); // {constructor: ƒ, eat: ƒ, sleep: ƒ, play: ƒ}

      tux_proto === Animal.prototype // true
    #+end_src


    two major takeaways:
    1. =prototype='s have every method defined on them + their constructor
       - this means that an instance of an object can access its own constructor
       - this occurs via delegation via =Object.create=, which implicitly happens between an object
         instance and its prototype using js =class='s and/or the pseudo-classical instantiation pattern
    2. =Animal.prototype= is the reference returned by =Object.getPrototypeOf(tux)= because they are the
       same thing
       - i don't know why mcginnis thinks this is worth saying, i guess he's just affirming it w/e

         
    side note: *.__proto__* is considered legacy, don't use that.

*** determining if a property lives on a prototype

    special cases arise where you want to know whether a property lives on an object instance or the
    prototype it delegates to.

    we can't use a =for in= loop because it'll return every property on an object instance, including
    its prototype's:
    #+begin_src js
    for(let key in tux) {
        console.log(`Key: ${key}. Value: ${tux[key]}`);
    }
    #+end_src

    as already said, it'll yield /every property/ on the object, including the object's prototype:
    #+begin_src js
      Key: name. Value: tux
      Key: energy. Value: 10
      Key: eat. Value: function (amount) {
          console.log(`${this.name} is eating.`)
          this.energy += amount
      }
      Key: sleep. Value: function (length) {
          console.log(`${this.name} is sleeping.`)
          this.energy += length
      }
      Key: play. Value: function (length) {
          console.log(`${this.name} is playing.`)
          this.energy -= length
      }
    #+end_src

    this is because =for in= loops iterate over all of the *enumerable properties* available on that
    object.

    to determine whether a property exists strictly /on an object instance/, use the boolean function =hasOwnProperty()=
    instead, which takes a property and checks whether the object has it:
    #+begin_src js
      for (let key in tux) {
          if (tux.hasOwnProperty(key)) {
              console.log(`Key: ${key}. Value: ${tux[key]}`);
          }
      }
    #+end_src

    which will yield the desired results:
    #+begin_src js
      Key: name. Value: tux
      Key: energy. Value: 10
    #+end_src

*** check if object is an instance of class
    =instanceOf= /operator/ does the trick:
    #+begin_src js
      tux instanceOf Animal // true
    #+end_src

    it functions by checking for the existence of the =constructor.prototype= in the object's
    prototype chain. this is true for =tux= because:
    #+begin_src js
      Object.getPrototypeOf(tux) === Animal.prototype
    #+end_src

*** creating new agnostic constructor functions

    how do you ensure a constructor function is always called with =new=? otherwise =this= is never
    constructor nor returned implicitly. to enforce this, realize that the =this= instance inside the
    constructor, if correctly called with =new=, will be an =instanceOf= that class. thus, we could do
    the following to enforce the usage of =new=:
    #+begin_src js
      function Animal(name, energy) {
          if (this instanceOf Animal === false) {
              throw new Error('did not construct object using new')
          }
          /* rest of code */
      }
    #+end_src

    better yet (is it really?).... we could just correct the error ourselves:
    #+begin_src js
      function Animal(name, energy) {
          if (this instanceOf Animal === false) {
              console.warn("failed to call Animal with new. corrected");
              return new Animal(name, energy)
          }
          /* rest of code */
      }    
    #+end_src

*** recreating the =Object.create()= method
    
    #+begin_src js
      Object.create = function(objToDelegate) {
          function Fn(){}
          Fn.prototype = objToDelegate;
          return new Fn()
      }
    #+end_src

    What is happening above:
    1. we create a function called =create= on the =Object= class
    2. inside that function, we define an empty function, =Fn=
    3. since every function has a prototype property, we assign to =Fn='s prototype the object we're
       delegating to
    4. finally, we use =new= to create /a new instance of that object/, which is what our empty =Fn=
       achieves because its prototype is that of the delegated object
       - thus, when we create a new object via =Object.create()=, the returned object, being an empty
         function, everything gets delegated to the passed object type's prototype.

*** arrow functions
    
    friendly reminder that arrow functions don't have =this= because they don't introduce their own
    context. by natural extension, this means they cannot be constructors. trying to do otherwise
    will return an error.

** lecture 12

*** why modules
    - reusability
    - composability
    - isolation
    - organization

*** js modules
    *modules*, generally speaking, are collections of code that together have a specific purpose with
    clear boundaries on its functionality and integration with other modules

    in js land, each module has three parts:
    1. imports (aka dependencies) - outside modules needed by the current module to function
    2. code - the actual code, i.e. logic/functionality, of th module
    3. exports (aka the interface) - the units of code exposed to the outside world and to be used by
       other modules

       
    here's an example taken out of the modules directory of the React Router library:
    #+begin_src js
      // imports
      import React from "react";
      import { createMemoryHistory } from "history";
      import Router from "./Router";

      // code
      class MemoryRouter extends React.Component {
          history = createMemoryHistory(this.props);
          render() {
              return (
                  <Router
                      history={this.history}
                      children={this.props.children}
                  />;
              )
          }
      }

      // exports
      export default MemoryRouter;
    #+end_src

*** js modules from the ground up

    js has a bad and weird history with modules so understanding how they work from the ground up
    can help with legacy code that still exists out there or something idk

    let's pretend it's the late 2000s. JQuery is the hot shit and people are starting to build
    enterprise size apps with js.

**** modules by file

     what if we made each file a module?
     #+begin_src js
       // users.js
       var users = ["odb", "rza", "gza"]

       function getUsers() {
         return users
       }

       // dom.js

       function addUserToDOM(name) {
         const node = document.createElement("li")
         const text = document.createTextNode(name)
         node.appendChild(text)

         document.getElementById("users")
           .appendChild(node)
       }

       document.getElementById("submit")
         .addEventListener("click", function() {
           var input = document.getElementById("input")
           addUserToDOM(input.value)

           input.value = ""
       })

       var users = window.getUsers()
       for (var i = 0; i < users.length; i++) {
         addUserToDOM(users[i])
       }
     #+end_src

     and here's how we serve it on our index.html:
     #+begin_src html
       <!-- index.html -->
       <!DOCTYPE html>
       <html>
         <head>
           <title>Users</title>
         </head>

         <body>
           <h1>Users</h1>
           <ul id="users"></ul>
           <input
             id="input"
             type="text"
             placeholder="New User">
           </input>
           <button id="submit">Submit</button>

           <script src="users.js"></script>
           <script src="dom.js"></script>
         </body>
       </html>
     #+end_src

     does this work? *nope*. nothing about how we've setup our files make them modules. as it stands,
     only functions can create their own contexts and thus every variable and function in each of
     the two files is introduced into the global namespace of our webpage. opening up the web
     console confirms this when you check our =window= object: 

     [[file:assets/Screenshot_20200525_155543.png]]

     =addUsers=, =users=, =getUsers=, and =addUsersToDOM= are all accessible. physical separation of code is
     the only thing achieved by our current setup.

     what can we do to actually modularize this code? what features, native to vanilla js, enable
     this sort of encapsulation?

     .... /what if we just wrap it all up in a function?/ let's make a single object, =APP=, that we
     expose at the global namespace level and put everything else about our app inside of it. We can
     put everything else in wrapper functions to keep it from polluting our global namespace.

     #+begin_src js
       // App.js
       var APP = {}


       // users.js
       function usersWrapper () {
         var users = ["odb", "rza", "gza"]

         function getUsers() {
           return users
         }

         APP.getUsers = getUsers
       }

       usersWrapper()


       // dom.js

       function domWrapper() {
         function addUserToDOM(name) {
           const node = document.createElement("li")
           const text = document.createTextNode(name)
           node.appendChild(text)

           document.getElementById("users")
             .appendChild(node)
         }

         document.getElementById("submit")
           .addEventListener("click", function() {
             var input = document.getElementById("input")
             addUserToDOM(input.value)

             input.value = ""
         })

         var users = APP.getUsers()
         for (var i = 0; i < users.length; i++) {
           addUserToDOM(users[i])
         }
       }

       domWrapper()
     #+end_src

     and add the following line before our other script calls in index.html:
     #+begin_src html
       <script src="app.js"></script>
     #+end_src


     looking at our =window= object, we now see there's a lot less pollution with only =APP= and our
     wrapper functions exposed. furthermore, because everything is inside of =APP= and wrapped up,
     none of the important code is exposed for direct manipulation like =users= was before.

     [[file:assets/Screenshot_20200525_155622.png]]

     is there way to go even further? can we eliminate the wrapper functions?

     note how we define and *then immediately invoke* our wrapper functions upon being loaded by their
     script tags in index.html. the only reason why they even have names is because we need to
     invoke them immediately, afterwards becoming useless to the client.

     ideally, we want a way to immediately invoke anonymous functions that setup the infrastructure
     of our application without polluting the global namespace with useless helpers/wrappers that
     don't do anything.

     what we want is called *Immediately Invoked Function Expressions*, aka *IIFE*'s

*** Immediately Invoked Function Expressions (IIFE)

    An *Immediately Invoked Function Expression* is an anonymous js function wrapped in parentheses
    that is immediately invoked upon evaluation by adding a trailing =()=:
    #+begin_src js
      (function () {
          console.log('look 'ma no hands)
      })()
    #+end_src

    note, the trailing =()= are necessary to invoke the function as is necessary for any js function
    to be invoked, e.g. =.toString()= vs =.toString=. evaluating only the expression wrapped in =()=
    results in nothing happening.

    let's apply our knowledge of IIEF's to our example application:
    #+begin_src js
      // App.js
      var APP = {}

      // users.js
      (function () {
          var users = ["odb", "rza", "gza"]

          function getUsers() {
              return users
          }

          APP.getUsers = getUsers
      })()

      // dom.js

      (function () {
          function addUserToDOM(name) {
              const node = document.createElement("li")
              const text = document.createTextNode(name)
              node.appendChild(text)

              document.getElementById("users")
                  .appendChild(node)
          }

          document.getElementById("submit")
              .addEventListener("click", function() {
                  var input = document.getElementById("input")
                  addUserToDOM(input.value)

                  input.value = ""
              })

          var users = APP.getUsers()
          for (var i = 0; i < users.length; i++) {
              addUserToDOM(users[i])
          }
      })()
    #+end_src

    our index.html remains untouched. 

    now when we eval =window= in our developer console, we get:
    [[file:assets/Screenshot_20200525_165228.png]]

    /perfecto/

    this pattern is called the *IIFE Module Pattern*

**** benefits of the IIFE Module Pattern
     avoid dumping everything into the global namespace
     - avoid collisions
     - keep code private

**** cons of IIFE Module Pattern
     - have one item in global namespace, =APP=
       + if anything else tries to use this name, trouble abounds
     - order of =<script>= tags matters a lot, problems will occur otherwise

*** module exports
    *each file is (nominally) its own module*, we just need to make it work by defining *explicit
    imports* and *explicit exports*.

    our module standard becomes:
    1. file based
    2. explicit imports
    3. explicit exports

*** defining our module api

    any information regarding the module can go on the *module* object so that anything we want to
    export we simply stick on =module.exports=:

    #+begin_src js
      var users = ["odb", "rza", "gza"]

      function getUsers() {
          return users
      }

      module.exports.getUsers = getUsers
    #+end_src

    equivalently:
    #+begin_src js
      var users = ["odb", "rza", "gza"]

      function getUsers() {
          return users
      }

      module.exports = {
          getUsers: getUsers
      }
    #+end_src

    we can make it even more condensed, and arbitrarily add as many exports as necessary:
    #+begin_src js
      // users.js
      var users = ["odb", "rza", "gza"]

      module.exports = {
          getUsers: function () {
              return users
          },
          sortUsers: function () {
              return users.sort()
          },
          // and so on
      }
    #+end_src

    now we need to resolve our import API. for simplicity, assume we have a function =require()= that
    takes a string path as its first argument and will return whatever is being exported from that
    path.

    to import our =users.js= file, we would do something like:
    #+begin_src js
      var users = require('./users')

      users.getUsers() // ["odb", "rza", "gza"]
    #+end_src

    we now have all the benefits of IIFE without any of the weird stuff. furthermore, this is of
    course a real standard, *CommonJS*

    #+begin_quote
    The CommonJS group defined a module format to solve JavaScript scope issues by making sure each
    module is executed in its own namespace. This is achieved by forcing modules to explicitly
    export those variables it wants to expose to the “universe”, and also by defining those other
    modules required to properly work.

    - Webpack docs
    #+end_quote

    this is more or less what node.js does, though it partially deviates from the spec. furthermore,
    browsers don't actually support =CommonJS= because *of its synchronous loading* of modules. Async is
    king in browser land.

    thus the two downsides of =CommonJS= are:
    1. browsers don't know it
    2. even if they did, it would be a bad UX because of synchronous loading.

*** Module Bundlers

    *javascript bundlers* examine your codebase, look at all the imports and exports, then
    intelligently bundles all of your modules together into a single file that the browser can
    understand. finally, instead of worrying about a shitton of =<script>= tags and their ordering,
    you just include a single =bundle.js= file to load.

    the process looks like:
    #+begin_quote
    app.js ---> |         |
    users.js -> | Bundler | -> bundle.js
    dom.js ---> |         |
    #+end_quote

    where all your files get inputted into the Bundler, and the Bundler gives you a functional
    =bundle.js= file to use and that the browser will understand.

    how do Bundlers work? *good question*, Tyler McGinnis doesn't understand them fully
    neither. However, here's what our code (=users.js= and =dom.js=) would look like went put through a
    basic webpack config:
    #+begin_src js
      (function(modules) { // webpackBootstrap
        // The module cache
        var installedModules = {};
        // The require function
        function __webpack_require__(moduleId) {
          // Check if module is in cache
          if(installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          // Create a new module (and put it into the cache)
          var module = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          // Execute the module function
          modules[moduleId].call(
            module.exports,
            module,
            module.exports,
            __webpack_require__
          );
          // Flag the module as loaded
          module.l = true;
          // Return the exports of the module
          return module.exports;
        }
        // expose the modules object (__webpack_modules__)
        __webpack_require__.m = modules;
        // expose the module cache
        __webpack_require__.c = installedModules;
        // define getter function for harmony exports
        __webpack_require__.d = function(exports, name, getter) {
          if(!__webpack_require__.o(exports, name)) {
            Object.defineProperty(
              exports,
              name,
              { enumerable: true, get: getter }
            );
          }
        };
        // define __esModule on exports
        __webpack_require__.r = function(exports) {
          if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
          }
          Object.defineProperty(exports, '__esModule', { value: true });
        };
        // create a fake namespace object
        // mode & 1: value is a module id, require it
        // mode & 2: merge all properties of value into the ns
        // mode & 4: return value when already ns object
        // mode & 8|1: behave like require
        __webpack_require__.t = function(value, mode) {
          if(mode & 1) value = __webpack_require__(value);
          if(mode & 8) return value;
          if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
          var ns = Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, 'default', { enumerable: true, value: value });
          if(mode & 2 && typeof value != 'string')
            for(var key in value)
              __webpack_require__.d(ns, key, function(key) {
                return value[key];
              }.bind(null, key));
          return ns;
        };
        // getDefaultExport function for compatibility with non-harmony modules
        __webpack_require__.n = function(module) {
          var getter = module && module.__esModule ?
            function getDefault() { return module['default']; } :
            function getModuleExports() { return module; };
          __webpack_require__.d(getter, 'a', getter);
          return getter;
        };
        // Object.prototype.hasOwnProperty.call
        __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        // __webpack_public_path__
        __webpack_require__.p = "";
        // Load entry module and return exports
        return __webpack_require__(__webpack_require__.s = "./dom.js");
      })
      /************************************************************************/
      ({

      /***/ "./dom.js":
      /*!****************!*\
        !*** ./dom.js ***!
        \****************/
      /*! no static exports found */
      /***/ (function(module, exports, __webpack_require__) {

      eval(`
        var getUsers = __webpack_require__(/*! ./users */ \"./users.js\").getUsers\n\n
        function addUserToDOM(name) {\n
          const node = document.createElement(\"li\")\n
          const text = document.createTextNode(name)\n
          node.appendChild(text)\n\n
          document.getElementById(\"users\")\n
            .appendChild(node)\n}\n\n
          document.getElementById(\"submit\")\n
            .addEventListener(\"click\", function() {\n
              var input = document.getElementById(\"input\")\n
              addUserToDOM(input.value)\n\n
              input.value = \"\"\n})\n\n
              var users = getUsers()\n
              for (var i = 0; i < users.length; i++) {\n
                addUserToDOM(users[i])\n
              }\n\n\n//# sourceURL=webpack:///./dom.js?`
      );}),

      /***/ "./users.js":
      /*!******************!*\
        !*** ./users.js ***!
        \******************/
      /*! no static exports found */
      /***/ (function(module, exports) {

      eval(`
        var users = [\"Tyler\", \"Sarah\", \"Dan\"]\n\n
        function getUsers() {\n
          return users\n}\n\nmodule.exports = {\n
            getUsers: getUsers\n
          }\n\n//# sourceURL=webpack:///./users.js?`);})
      });
    #+end_src
    To get a better understanding, read the comments in the output above.

    The biggest takeaway for the above snippet, aside from integrating all of our code together into
    one output, is that the entire snippet is *one big IIFE*.

*** ES Modules

    So TC-39 finally resolved to designing a builtin JS module system, and it improves on our IIFE
    and CommonJS style system by:
    - making it async by default
    - adding explicitly new keywords, =import= and =export=, instead of a helper function =require= and
      respecting norms around the usage of =module= identifiers

      
    take the following example =util.js= file:
    #+begin_src js
      // utils.js

      // Not exported
      function once(fn, context) {
        var result
        return function() {
          if(fn) {
            result = fn.apply(context || this, arguments)
            fn = null
          }
          return result
        }
      }

      // Exported
      export function first (arr) {
        return arr[0]
      }

      // Exported
      export function last (arr) {
        return arr[arr.length - 1]
      }
    #+end_src

    every exported function is prepended with the =export= keyword.

    there are a few options for *importing* es modules.

    1. importing everything
       #+begin_src js
         import * as utils from './utils'

         utils.first([1,2,3]) // 1
         utils.last([1,2,3]) // 3
       #+end_src

    2. *named imports*
       #+begin_src js
         import { first } from './utils'

         first([1,2,3]) // 1
       #+end_src

    3. (if available) *default imports*
       with es modules, you can define a *default* export.
       #+begin_src js
         // leftpad.js

         export default function leftpad (str, len, ch) {
           var pad = '';
           while (true) {
             if (len & 1) pad += ch;
             len >>= 1;
             else break;
           }
           return pad + str;
         }

         // app.js
         import leftpad from './leftpad'
       #+end_src

       these =default= imports can be mixed with normal exports as well:
       #+begin_src js
         import leftpad, { first, last } from './utils'
       #+end_src


    returning to our original example, we can leverage ES modules as so:
    #+begin_src js
      // users.js

      var users = ["odb", "rza", "gza"]

      export default function getUsers() {
        return users
      }

      // dom.js

      import getUsers from './users.js'

      function addUserToDOM(name) {
        const node = document.createElement("li")
        const text = document.createTextNode(name)
        node.appendChild(text)

        document.getElementById("users")
          .appendChild(node)
      }

      document.getElementById("submit")
        .addEventListener("click", function() {
          var input = document.getElementById("input")
          addUserToDOM(input.value)

          input.value = ""
      })

      var users = getUsers()
      for (var i = 0; i < users.length; i++) {
        addUserToDOM(users[i])
      }
    #+end_src

    *ES modules are native to js and thus browsers support them without a bundler*. unlike the plain
     IIFE pattern, we don't need to worry about ordering and sourcing several JS files in our
     html. Furthermore, unlike CommonJS, we don't need a bundler to make the browser understand our
     modules. /Furthermore/, all we need to do is source the major/primary js module and add
     ~type='module'~ attribute to the script tag:
     #+begin_src js
       <!DOCTYPE html>
       <html>
         <head>
           <title>Users</title>
         </head>

         <body>
           <h1>Users</h1>
           <ul id="users">
           </ul>
           <input id="input" type="text" placeholder="New User"></input>
           <button id="submit">Submit</button>

           <script type=module src='dom.js'></script>  </body>
       </html>     
     #+end_src

*** tree shaking
    another aspect of ES modules is that they are *static* and are *required to be declared at the top
    of the module*. With CommonJS style modules, you can =require= a module anywhere and can therefore
    even conditionally import module code:
    #+begin_src js
      if (pastTheFold === true) {
          require('./foo')
      }
    #+end_src
    the same is invalid for ES modules (though there is a stage 3 proposal for a similar feature).

    the benefit to static modules is that it allows for static analysis and optimization of imports
    via *tree shaking*, which is just dropping dead/unused code from your import bundle.

** lecture 13
*** Class Fields
   as of now, field variables of a class in ES6 are declared in the constructor:
   #+begin_src js
     constructor() {
         this.foo = 0
         this.bar = "bar"
         /* etc */
     }
   #+end_src

   however, there is a stage 3 proposal in TC-39 for *declaring class fields* (properties) directly
   onto a class as opposed to needing their declaration and instatiation within the constructor:
   #+begin_src js
     class Foo extends Bar {
         foo = 0
         bar = "bar"
         someClassMethod() {
             // whatever
         }
         /* rest of class */
     }
   #+end_src

   this is nice and all, but really benefits react code. here's a typical react component:
   #+begin_src js
     class PlayerInput extends Component {
       constructor(props) {
         super(props)
         this.state = {
           username: ''
         }

         this.handleChange = this.handleChange.bind(this)
       }
       handleChange(event) {
         this.setState({
           username: event.target.value
         })
       }
       render() {
         ...
       }
     }

     PlayerInput.propTypes = {
       id: PropTypes.string.isRequired,
       label: PropTypes.string.isRequired,
       onSubmit: PropTypes.func.isRequired,
     }

     PlayerInput.defaultProps = {
       label: 'Username',
     }
   #+end_src

   now here's the same component using the class fields declaration, starting with moving =state= out:
   #+begin_src js
     class PlayerInput extends Component {
       state = {
         username: ''
       }
       constructor(props) {
         super(props)

         this.handleChange = this.handleChange.bind(this)
       }
       handleChange(event) {
         this.setState({
           username: event.target.value
         })
       }
       render() {
           /* snip */
       }
     }

     PlayerInput.propTypes = {
       id: PropTypes.string.isRequired,
       label: PropTypes.string.isRequired,
       onSubmit: PropTypes.func.isRequired,
     }

     PlayerInput.defaultProps = {
       label: 'Username',
     }
   #+end_src

   what is annoying is that we still need to add the properties =propTypes= and =defaultProps= after the
   declaration of =PlayerInput= because of the limits on =static= usage, i.e. only methods and not
   values can be made static.

   luckily, the Class Fields proposal includes this functionality!
   #+begin_src js
     class PlayerInput extends Component {
       static propTypes = {
         id: PropTypes.string.isRequired,
         label: PropTypes.string.isRequired,
         onSubmit: PropTypes.func.isRequired,
       }
       static defaultProps = {
         label: 'Username'
       }
       state = {
         username: ''
       }
       constructor(props) {
         super(props)

         this.handleChange = this.handleChange.bind(this)
       }
       handleChange(event) {
         this.setState({
           username: event.target.value
         })
       }
       render() {
         /* ... */
       }
     }
   #+end_src

   awesome, now all we have left is an ugly constructor method that does nearly nothing. all it does
   is call =super()= and attach =this= to the instance object to ensure proper context for our call to =handleChange=.

   ... what if we just use an arrow function for =handleChange= then?

   #+begin_src js
     class PlayerInput extends Component {
       static propTypes = {
         id: PropTypes.string.isRequired,
         label: PropTypes.string.isRequired,
         onSubmit: PropTypes.func.isRequired,
       }
       static defaultProps = {
         label: 'Username'
       }
       state = {
         username: ''
       }
       handleChange = (event) => {
         this.setState({
           username: event.target.value
         })
       }
       render() {
         /* ... */
       }
     }
   #+end_src

*** downsides of class fields
    
    recall that =class= is just syntactic sugar over the psuedo-classical pattern of attaching shared
    methods to an object type's prototype (it's constructing function's prototype). this is
    performant because they are not dynamic, i.e. each instance does not re-create the function
    method. the issue with class fields is, by definition, they are defined on the class
    instantiation. there is overhead with this and so, maybe for larger and commonly used components
    of a project, can be a significant performance cost.

    for example, if we used an arrow function to make =sleep= a class field in =Animal=:
    #+begin_src js
      class Animal {
        eat() {}
        sleep = () => {}
      }

      // Is equivalent to

      function Animal () {
        this.sleep = function () {}
      }

      Animal.prototype.eat = function () {}
    #+end_src

*** private fields

    historically js had no notion of private fields because there is no real mechanism to prevent
    consuming code to access it, so an underscore that prefixed a variable name was a signal to
    "please not use this variable and treat it as private". again, not enforceable though.
    #+begin_src js
      class Car {
        _milesDriven = 0
        drive(distance) {
          this._milesDriven += distance
        }
        getMilesDriven() {
          return this._milesDriven
        }
      }

      const tesla = new Car()
      tesla.drive(10)
      console.log(tesla._milesDriven) // returns 10, completely valid despite being "private"
    #+end_src

    The Class Field proposal now also formalizes actual *private fields* via the =#= symbol:
    #+begin_src js
      class Car {
        #milesDriven = 0
        drive(distance) {
          #milesDriven += distance
        }
        getMilesDriven() {
          return #milesDriven
        }
      }

      const tesla = new Car()
      tesla.drive(10)
      tesla.getMilesDriven() // 10
      tesla.#milesDriven // Invalid
    #+end_src

* react
  :PROPERTIES:
  :header-args: :mkdirp yes
  :END:
** overview
*** why react
    *react* is a library for building user interfaces. there is a large ecosystem, but that's
    ultimately what react is about.

    benefits of react:
    - *Composition*
      + we compose functions all the time for backend logic, but what if we made UI also compositional?

        #+begin_src jsx :tangle "react_ex/ex_prop.js"
          function profilePic(props) {
              return (
                  <img src={'https://photo.fb.com/' + props.username}/>
              )
          }

          function profileLink(props) {
              return (
                  <a href={'https://fb.com/' + props.username}>{props.username}</a>
              )
          }

          function avatar(props) {
              return (
                  <div>
                      <profilePic username={props.username} />
                      <profileLink username={props.username} />
                  </div>
              )
          }

          <avatar username='ejmg'>
        #+end_src

      + composition allows you to leverage 3rd party components trivially

    - *Unidirectional Dataflow*

      + predictable and robust applications requires knowing *when* and *how* state changes

      + old school JQuery would result in event listeners that were complex, intermingled, and shared
        mutable state (the dom itself)
        [[file:assets/jquery.png]]

      + with react, the source of truth (state) *lives in the components*. in components, you decide
        when/how state should change along with how that effects the UI
        [[file:assets/react-flow.png]]

      + UI becomes a function of state

    - *Declarative UI*

      + in addition to unidirectional dataflow is *how* the DOM gets updated.

        * with JQuery, it's imperative code:
          #+begin_src js
            $('btn').click(() => {
              $(this).toggleClass('highlight')
              $(this).text() === 'Add Highlight'
                ? $(this).text('Remove Highlight')
                : $(this).text('Add Highlight')
            })
          #+end_src

        * with react, the abstraction of imperative programming is taken away. instead, you *describe
          what* the UI should look like, *not how* it gets updated. react does the hardwork of figuring
          out those changes /for you/.

      + with react, you now only need to worry about:
        1. how the state in a component changes

        2. what the UI looks like based off of the state

    - *"it's just javascript"*

      + controversial, but really, it's just js. other frameworks have directives or infra to
        transform code, when react is just js.

        * Vue has a special API for for-loops called =v=for= directive
          #+begin_src html
            <ul id="friends">
              <li v-for="friend in friends">
                {{ friend }}
              </li>
            </ul>
          #+end_src

        * with react... you just use =.map=:
          #+begin_src html
            <ul>
              {friends.map((name) => (
                <li>
                  {name}
                </li>
              ))}
            </ul>
          #+end_src
*** the react ecosystem

    react itself isn't all that confusing, but getting react working within the front-end system,
    especially for the first time, is. you need NPM, Babel, and Webpack altogether working to get
    react loaded as expected. To get routing, you need to bring in React Router, and what about
    Redux? etc.
   
**** react itself

     react is all about UI, so why is it so complicated to get running? well, you could get it
     running with only an =index.html= page:
     #+begin_src html :tangle "react_ex/index.html"
       <!DOCTYPE html>
       <html>
       <head>
         <title>React</title>
         <script crossorigin src="https://unpkg.com/react@16.7/umd/react.development.js"></script>
         <script crossorigin src="https://unpkg.com/react-dom@16.7/umd/react-dom.development.js"></script>
         <script src='https://unpkg.com/babel-standalone@6/babel.min.js'></script>
       </head>
       <body>
         <div id='app'></div>
         <script type='text/babel'>
           function Hello ({ name }) {
             return <h1>Hello, {name}</h1>
           }

           ReactDOM.render(
             <Hello name='ghostface killah' />,
             document.getElementById('app')
           )

         </script>
       </body>
       </html>
     #+end_src

     is this the best way to do it? no. is it possible? yes.

***** why is setting up react so complicated?

      for a production ready build, the setup is legitimately more complicated. why? let's
      investigate with code. here's a component:
      #+begin_src js :tangle "react_ex/ecosystem/component.js"
        import React from 'react'

        export default function User ({ name, username }) {
          const avatarURL = `https://github.com/${username}.png?size=200`

          return (
            <div>
              <h1>{name}</h1>
              <img 
                alt={`Avatar for ${username}`}
                src={avatarURL}
              />
            </div>
          )
        }
      #+end_src

      if we gave this component as is to a browser, it would throw an error because, well, it would
      think we gave it malformed js. it looks like we have html in our js; alternatively, it would
      possibly give a syntax error on import/export syntax. both of these errors are a result of how
      react works and why the build/deployment of react is more complicated.

***** babel and react
     
      babel is a transpiler for modern javascript into equivalent web browser compatible
      javascript. the first issue with the component above, the embedded html, is a result of *JSX*
      (TBD). JSX is react's way of describing of describing UI inside of components.


      thus, we need babel in our toolchain by necessity. in order to run jsx in the browser, we need
      to transpile it via babel (or an equiv tool) into browser compatible js.

***** webpack

      webpack is a popular js bundler tool that takes your javascript and packages it such that the
      browser will understand it while maintaining functionality and maintaining the program
      namespace. furthermore, it *removes* the import/export statements that browsers don't understand
      yet.

***** routing

      *react does not come with its own router*. at the end of the day, react is a UI library; however,
      there are router libraries for react, most notably/popular being React Router (TBD). tl;dr,
      the below example shows how react router's job is to *render specific components based on the
      current URL path of the user*:
      #+begin_src js :tangle "react_ex/ecosystem/router.js"
        <Router>
          <div>
            <ul>
              <li><Link to="/">Home</Link></li>
              <li><Link to="/about">About</Link></li>
              <li><Link to="/topics">Topics</Link></li>
            </ul>

            <Route exact path="/" component={Home}/>
            <Route path="/about" component={About}/>
            <Route path="/topics" component={Topics}/>
          </div>
        </Router>
      #+end_src

      when a user navigates to the home page at ~/~, react router will render the =Home= component,
      etc. what is important/nice about react router is that its entire API consists of just
      *components*.

***** styling

      /styling is the most controversial part of the react ecosystem (lol)/. There are two schools of
      thought:
      1. traditional
         - style your react apps like you would any other web app, e.g. =index.css= for the index or
           =user_profile.css= for user profile stylings etc
           + you have classes, cascading, and other css native features
           + maybe even css pre-processors like SASS or pureCSS
         - standard pro/cons of css apply here
      2. untraditional
         - fully embraces react's component model by including styling alongside the logic/ui in components
           + *"CSS in JS"*
           + you avoid all the typical properties of CSS, e.g. no more cascading or global namespace
           + all your styles for a component live in the component just like the UI and static logic
         - example:
           #+begin_src js
             // styles become objects to create for specific components
             const styles = {
               header: {
                 fontWeight: 400,
                 fontSize: 55,
                 color: '#a41c1c'
               },
               avatar: {
                 width: 50,
                 height: 50,
                 borderRadius: 25
               }
             }

             export default function User ({ name, username }) {
               const avatarURL = `https://github.com/${username}.png?size=200`

               return (
                 <div>
                   <h1 style={styles.header}>{name}</h1>
                   <img
                     style={styles.avatar}
                     alt={`Avatar for ${username}`}
                     src={avatarURL}
                   />
                 </div>
               )
             }
           #+end_src
         - a popular library for this approach is the Styled Components library, which allows the
           creation of style components:
           #+begin_src js
             import React from 'react'
             import styled from 'styled-components'

             const Header = styled.h1`
               font-weight: 400;
               font-size: 55;
               color: #a41c1c;
             `

             const Avatar = styled.img`
               width: 50px;
               height: 50px;
               border-radius: 25px;
             `

             export default function User ({ name, username }) {
               const avatarURL = `https://github.com/${username}.png?size=200`

               return (
                 <div>
                   // note how the component tag here is a Style Component, as is Image
                   <Header>{name}</Header>
                   <Image
                     alt={`Avatar for ${username}`}
                     src={avatarURL}
                   />
                 </div>
               )
             }
           #+end_src

***** redux
     
      Redux is a state container for js. it basically helps coordinate/setup/control state change in
      your components, and is not actually dependent/required to be used with react itself, but any
      "view" library generally.

      the difference in how plain react handles its state and how redux handles state helps
      illuminate their differences and behavior.

      react says that each component has its own state and is the logical organizer/container for
      it. you then compose together components to create an app, which each act similarly. redux, on
      the other hand, aggregates state in one location called a "Store" which in turn has a set of
      strict rules for how the state can be changed.

      one note on redux is that it was seriously overhyped as a tool. when it is the right tool for
      the job, it is excellent; otherwise, it is very much overkill. the best way to appreciate redux
      is to learn react first and then approach redux.
** road to hello world
*** modules, CDNs, and script tags
    modules are nice and there are a lot of ways to use them. one big one is sourcing your scrips
    via a CDN, another is sourcing it locally:
    #+begin_src html
      <body>

        <!-- snip -->

        <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
        <script src="libs/react.min.js"></script>
      </body>
    #+end_src

    problems with this approach:
    1. if CDN goes down, your app goes down
    2. with more than one script tag, order suddenly becomes a concern
       - load something wrong, out of order, and it breaks
    3. versioning
       - if a package upgrades, need to hope CDN either puts up new version and/or they keep up old
         version for your use case
       - similarly, need to re-download if sourcing locally for upgrades

         
    problem becomes evident once you have more than a few scripts. what does an ideal solution look
    like, then?
    - make it easier to DL packages
    - make it easier to upload packages
    - make it easier to switch versions
    - do it all for free

      
    congrats, we have just described npm
    
*** npm

    npm is a for-profit co. that maintains the package manager npm, node package manager. npm
    consists of two pieces:
    1. the registry
    2. the cli tool

**** =npm init=
     - =npm init= to start a project
       + generates a =package.json= and =node_modules/= dir
     - =node_modules=: when you install a package, the source code is found here
       + when you import a module and it's not in your file path, your app looks in here
     - =package.json=: contains all the meta info for your project. it contains the name, the author's
       name, description, and the list of packages (and their versions) needed to run the project
       + ex:
         #+begin_src js
           {
             "name": "github-battle",
             "version": "1.0.0",
             "description": "Compare two Github user's profile.",
             "author": "Tyler McGinnis",
             "license": "ISC",
             "homepage": "https://github.com/tylermcginnis/react-course#readme",
             "keywords": [
               "react",
               "react-router",
               "babel",
               "webpack"
             ],
             "repository": {
               "type": "git",
               "url": "git+https://github.com/tylermcginnis/react-course.git"
             },
             "main": "index.js",
             "dependencies": {
               "prop-types": "^15.7.2",
               "query-string": "^6.2.0",
               "react": "^16.8.3",
               "react-dom": "^16.8.3",
               "react-icons": "^3.4.0",
               "react-router-dom": "^4.3.1"
             },
             "devDependencies": {
               "@babel/core": "^7.3.4",
               "@babel/plugin-proposal-class-properties": "^7.3.4",
               "@babel/preset-env": "^7.3.4",
               "@babel/preset-react": "^7.0.0",
               "babel-loader": "^8.0.5",
               "babel-plugin-syntax-dynamic-import": "^6.18.0",
               "copy-webpack-plugin": "^5.0.0",
               "css-loader": "^2.1.0",
               "html-webpack-plugin": "^3.2.0",
               "style-loader": "^0.23.1",
               "webpack": "^4.29.5",
               "webpack-cli": "^3.2.3",
               "webpack-dev-server": "^3.2.1"
             },
             "scripts": {
               "start": "webpack-dev-server --open",
               "build": "NODE_ENV='production' webpack",
             }
           }
         #+end_src

**** =package.json=
     a few properties worth mentioning from above:
     - =dependencies=: modules needed for your app to run
       + whenever you install a new package, the source for that package is DL'd and added to
         =node_modules=, along with its name and version info in the package.json
     - =devDependencies=: the packages needed for just development. same story as ^^.

**** =npm install=
     the reason tracking things like =dependencies= and =devDependencies= in your =package.json= is so
     important is because if someone else decides to install your program, they need all of that
     information for it to work. in fact, that's what =npm install= as a command is for: it takes the
     information known about your program in =package.json= and uses that to rebuild it.

**** scripts
     another property in =package.json= is =scripts=, which allows you to specify tasks to automate. in
     the example given, two are defined already: =start= and =build=

     to run a script, simply =cd= into the project directory containing the =package.json= and execute
     =npm run <script_name>=

**** installing packages

     simple as =npm install <package_name>=. if it's on the npm registry and works with the versions
     of existing installed modules, it'll be installed and have its meta data added to the
     =package.json=.

     to designate a dev dep, it's just =npm install <pkg> --save-dev=

**** publishing packages
     to publish:
     - =package.json= needs to have:
       + info for =name=
       + =version=
       + =main= (entry point into the package).
     - then run =npm login=
       + run through that + make acct as nec
     - =npm publish=
     - probably better to just follow the [[https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry][npm publishing guide]] 

**** versioning
     *semantic versioning* is gudt. when given a version like =v1.2.3=, it has three components to its
     version:
     - the first is its *major version*, which is =1=
       + these are *breaking changes*, like changing the public API in any way
     - the *minor version* is =2=
       + a *non-breaking* feature that is added is such a minor-change
     - the *patch version* is =3=
       + everything else that isn't breaking or non-breaking feature additions

         
     npm provides tools to prevent the usage of incompatible packages:
     - =^= in a version denotes to install the most recent package *with the same major version*
       + ex:
         #+begin_src js
           "dependencies": {
               "prop-types": "^15.7.2", // install the newest of prop-types that is v15, could be any vz.x.y such that x > 7 and y > 2 but z == 15 always
               "query-string": "^6.2.0",
               "react": "^16.8.3",
               "react-dom": "^16.8.3",
               "react-icons": "^3.4.0",
               "react-router-dom": "^4.3.1"
           }
         #+end_src
     - =​~​=: in a version means that *major and minor* must match
       + e.g. if ="prop-types": "~15.7.2"= then whatever version of =prop-types= installed better have =v15.7.y=
     - *exact version*: simply put the version number with no prefix symbol. it will always require
       that version, no exceptions.

*** webpack

**** why does webpack exist
     it's a bundler that makes the browser understand your code in terms of dependencies and imports
     so that your =index.html= can call and reference it

**** what problem is solved by webpack?
     avoid having multiple =<script>= tags that need to be sourced, which introduce the issue of
     dependency ordering, typos, or forgetting an import.

     it can also do other useful things like packaging and transforming your SASS into CSS, ES6 into
     ES5 that the browser understands.

     *to install* for a new project, =npm install webpack webpack-cli --save-dev=

**** =webpack.config.js=
     to configure webpack for a specific project, we create and customize our =webpack.config.js=
     file. this exports an object that contains all of these customizations:
     #+begin_src js
       module.exports = {}
     #+end_src

     
     recall, the whole point of webpack is to:
     1. examine all your modules
     2. (optionally) transform them
     3. intelligently put then together into one or more bundles

        
     to do this, webpack needs:
     1. the entry point of your application
     2. which transformations, if any, to perform
     3. the location to put the newly transformed bundle(s)

***** entry point

      whenever your app is composed of modules, *there is always a module that serves as the entry
      to the app*. often times it is an =index.js= file like so:
      #+begin_verse
      index.js
      |- imports about.js
      |- imports dashboard.js
         |- imports graph.js
         |- imports auth.js
            |- imports api.js
      #+end_verse

      with the entry point, webpack then builds the *dependency graph of our app*. To give that entry
      point:
      #+begin_src js
        module.exports = {
          entry: './app/index.js'
        }
      #+end_src

***** transformations with loaders

      with an entry point, now we can tell what transformations we want, if any. to do this, we use
      *loaders*.

      when building the dependency graph, webpack looks at all your =import= and =export= statements and
      only knows how to handle =js= and =json= files, which makes the following problematic:
      #+begin_src js
        import auth from './api/auth' 
        import config from './utils/config.json' 
        import './styles.css' 
        import logo from './assets/logo.svg' 
      #+end_src

      there's a good chance we'll want things besides just =js= and =json= for our application, such as
      =css= for stylings, graphics (like =svg=), and image for the app to render. this is exactly what
      loaders are for, as they give webpack the /ability to load more than just js and json files/.

      to use a loader:
      1. install it
         - for svg's: =npm install svg-inline-loader --save-dev=.
      2. add it to =webpack.config.js=
         - *all information for loaders go into an array of objects* under =module.rules=
           + for =svg-inline-loader=
             #+begin_src js
               module.exports = {
                 entry: './app/index.js',
                 module: {
                   rules: []
                 }
               }
             #+end_src
         - *two pieces of info needed for each loader*:
           1. the type of file we want our loader to run on
           2. the loader to use on that file type
         - defined by an object with the properties =test= and =use= in our rule array.
           + =test= is going to be a regex to match the file path
           + =use= is just the loader
           + for =svg-inline-loader=, we update our rules:
             #+begin_src js
               module.exports = {
                 entry: './app/index.js',
                 module: {
                     rules: [
                         { test: /\.svg$/, use: 'svg-inline-loader' }
                     ]
                 }
               }
             #+end_src

             
      now our app can import =svg='s as needed. we can do the same process for =css=:
      1. install the loader
         - =npm install css-loader --save-dev=
      2. add it to =module.rules=
         #+begin_src js
           module.exports = {
             entry: './app/index.js',
             module: {
               rules: [
                 { test: /\.svg$/, use: 'svg-inline-loader' },
                 { test: /\.css$/, use: 'css-loader' }
               ]
             }
           }
         #+end_src

           
      but wait: we want the ability to /import/ *and* /use/ our css, i.e. inject them into the DOM. what
      we want is to import our css and then webpack /put all the css into <style> tags in the DOM/. we
      need one more loader to do this: =style-loader=

      let's add that loader:
      1. =npm install style-loader --save-dev=
      2. add it to =module.rules=
         #+begin_src js
           module.exports = {
             entry: './app/index.js',
             module: {
               rules: [
                 { test: /\.svg$/, use: 'svg-inline-loader' },
                 { test: /\.css$/, use: [ 'style-loader', 'css-loader' ] }
               ]
             }
           }
         #+end_src
         + note that we made =use= an /array of loaders to use on the =test= case/
         + further note that we have =style-loader= *before* =css-loader=, this is critical because
           webpack will *process these in reverse order*


      turning modern js, i.e. es6, into browser friendly js follows the same pattern via babel and
      wepback. what we want is the =babel-loader=:
      1. =npm install babel-loader --save-dev=
      2. update our webpack config:
         #+begin_src js
           module.exports = {
             entry: './app/index.js',
             module: {
               rules: [
                 { test: /\.svg$/, use: 'svg-inline-loader' },
                 { test: /\.css$/, use: [ 'style-loader', 'css-loader' ] },
                 { test: /\.(js)$/, use: 'babel-loader' }
               ]
             }
           }
         #+end_src

***** the output of webpack

      to tell webpack where to put its bundled output, specify it via the =output= property:
      #+begin_src js
        const path = require('path')

        module.exports = {
          /* snip */
          output: {
            path: path.resolve(__dirname, 'dist'),
            filename: 'index_bundle.js'
          }
        }
      #+end_src


      thus *full webpack process looks like*:
      1. webpack gets the entry point =app/index.js=
      2. it examines all import/export statements and creates a dependency graph
      3. webpark starts creating a bundle
         - whenever it comes across a path we have a loader for, it transforms the code according to
           the loader and adds it to the bundle
      4. it takes the final bundle and outputs it to =dist/index_bundle.js=

***** plugins

      *plugins* allow you to execute tasks /after/ the bundle has been created. that means plugins can
      be tasks on the bundle itself or the codebase. they are effectively /more powerful, less
      restrictive/ versions of loaders. =plugins= exist as an array property on =modules.export=.

      here are some example plugins that are common and useful.

****** =HtmlWebpackPlugin=

       This plugin automatically generates the =index.html= page for our application and stick it into
       the same directory where our bundle is generated, along with the =<script>= tag that references
       the bundle.

       this is really convenient because it automatically handles the overhead of changing paths and
       outputs wrt =index.html= whenever we edit these values in our =webpack.config.js= file.

       to use it:
       1. =npm install html-webpack-plugin --save-dev=
       2. add to =module.rules=
          #+begin_src js
            const path = require('path')
            const HtmlWebpackPlugin = require('html-webpack-plugin')

            module.exports = {
              /* snip */
              plugins: [
                new HtmlWebpackPlugin()
              ]
            }
          #+end_src
       
****** =EnvironmentPlugin=

       This plugin allows us to declare environment variables that signal to our web application
       when deployed to production/staging/dev and change behavior accordingly. This plugin is
       included in the webpack namespace because of how common/useful of a utility, so installing
       isn't necessary.

       to setup:
       #+begin_src js
         const path = require('path')
         const HtmlWebpackPlugin = require('html-webpack-plugin')
         const webpack = require('webpack')

         module.exports = {
           /* snip */
           plugins: [
             new HtmlWebpackPlugin(),
             new webpack.EnvironmentPlugin({
               'NODE_ENV': 'production'
             })
           ]
         }
       #+end_src

       where =process.env.NODE_ENV= is the env variable we care about, and setting it to =production=
       tells react to strip out dev features like warnings, etc.

**** mode

     when you build an app for production, there are steps you need to take. one is described above,
     which is setting the =process.env.NODE_ENV= variable to =production=. Another two are *minifying
     your code* and *stripping out comments*, both of which *reduce bundle size*

     we could use plugins for each of these tasks, but webpack allows an easier method via the =mode=
     property, which you can set to =production= or =development=.

     This allows us to *drop the EnvironmentPlugin* wrt setting =process.env.NODE_ENV= while also
     achieving minification:
     #+begin_src js
       const path = require('path')
       const HtmlWebpackPlugin = require('html-webpack-plugin')

       module.exports = {
         /* snip */
         plugins: [
           new HtmlWebpackPlugin()
         ],
         mode: 'production'
       }
     #+end_src

**** Running webpack

     assuming we have npm and a =package.json= file, just add a script:
     #+begin_src js
       "scripts": {
         "build": "webpack"
       }
     #+end_src

     this will result in an optimized =index_bundle.js= along with an =index.html= under =dist/=

**** running production vs development modes

     let's make it easier to change between running =production= and =development= modes by adding some
     script commands:
     - =npm run start= will be the development build/server, which allows for code reloading and
       warning generation, etc.
     - =npm run build= will be the production release


     we can adjust our =scripts= property in =package.json= to reflect the need to change the value of
     =mode= in =webpack.config.js=.
     #+begin_src js
       // in package.json
       "scripts": {
         "build": "NODE_ENV='production' webpack",
       }

       // in webpack.config.js, change the `mode` property to:
       module.exports = {
           /* snip */
           mode: process.env.NODE_ENV === 'production' ? 'production' : 'development'
       }
     #+end_src

     now our =process.env.NODE_ENV= gets properly set as needed because =mode= gets properly set between
     our =start= and =build= command scripts.

**** webpack DevServer

     when developing code, we want speed, not production quality deployments, when working on code
     changes. =webpack-dev-server= helps with this by providing a development server for webpack. this
     will keep our development files in memory and serve them locally instead of generating and
     deploying them to =dist/=. this affords us *live code reloading*, which means changes we make in
     our source code get recompiled quickly and reloaded into our browser for testing/development.

     to use webpack server:
     1. =npm install webpack-dev-server --save-dev=
     2. edit our =start= script
        #+begin_src js
          "start": "webpack-dev-server"
        #+end_src
*** react elements vs components
**** what is a react element?
     there is a layer of abstraction between jsx and what react is actually doing which, in turn,
     effects how we need to think about different parts of react.

     one way to think about *react elements* is that they /describe what you want to see on the
     screen/. put more explicitly, a *react element is an*object representation of a DOM
     node*. ultimately, react elements are not what you see on the screen -- react generates an
     /object representation of it/.

     why? there are good reasons for it:
     - js objects are lightweight
       + react can create/destroy w/o much overhead
     - react can analyze the object and diff it with the previous representation
       + figure out what has and has not changed
       + allows perf opts

         
     to create a basic react element:
     #+begin_src js
       const element = React.createElement(
         'div',
         {'id': 'login-btn'},
         'login'
       )
     #+end_src

     =createElement()= takes three args:
     1. the tag name (=div=, =li=, etc)
     2. any attributes you want the element to have
     3. contents, or children, of the element
        - in above ex, it's just the text "login", but could other elements

          
     the above example returns the following object:
     #+begin_src js
       {
         type: 'div',
         props: {
           children: 'Login',
           id: 'login-btn'
         }
       }
     #+end_src
     
     
     when rendered to the DOM, via =ReactDOM.render()=, we'll have a new DOM node that looks like:
     #+begin_src html
       <div id='login-btn'>login</div>
     #+end_src

     what are react components, then? a *react component* is a /functions or class which optionally
     accepts input and returns a *react element*/

     let's define a react component that yields us our react button element:
     #+begin_src js
       function Button({ onLogin }) {
         return React.createElement(
           'div',
           {id: 'login-btn', onClick: onLogin },
           'login'
         )
       }
     #+end_src
     our =Button= component:
     - accepts an =onLogin= method (input) as its prop
     - for =Button= to render our element, it passes the prop as the second argument
     - assigns the inner value as 'login' still

**** going deeper

     you can make react elements out of more than basic html tags, including other react components
     #+begin_src js
       const element = React.createElements(
         User,
         {name: 'elias'},
         null
       )
     #+end_src

     when react sees a class or function as its first argument to =createElements()=, *it checks to see
     what element it renders* given the corresponding props. it continue to progress downward until
     there are no more =createElement= invocations which have a class/function as their first
     argument.

     here's an example:
     #+begin_src js
       function Button({ addFriend }) {
         return React.createElement(
           "button",
           { onClick: addFriend },
           "add friend"
         )
       }

       function User({ name, addFriend }) {
         return React.createElement(
           "div",
           null,
           React.createElement(
             "p",
             null,
             name
           ),
           React.createElement(Button, { addFriend })
         )
       }
     #+end_src

     the above snippet has two components, =User= and =Button=, with the former returning a DOM node
     that will be a =div= with two children, a =p= that wraps the user name and a =Button= component.

     here's what these components look like when we swap the =createElement= invocations with the
     objects they create:
     #+begin_src js
       function Button ({ addFriend }) {
         return {
           type: 'button',
           props: {
             onClick: addFriend,
             children: 'Add Friend'
           }
         }
       }

       function User ({ name, addFriend }) {
         return {
           type: 'div',
           props: {
             children: [
               {
                 type: 'p',
                 props: {
                   children: name
                 }
               },
               {
                 type: Button,
                 props: {
                   addFriend
                 }
               }
             ]
           }
         }
       }
     #+end_src

     at the end of the process, react will have a full representation of the DOM tree for that set
     of components. for the above:
     #+begin_src js
       {
         type: 'div',
         props: {
           children: [
             {
               type: 'p',
               props: {
                 children: 'elias'
               }
             },
             {
               type: 'button',
               props: {
                 onClick: addFriend,
                 children: 'add friend'
               }
             }
           ]
         }
       }
     #+end_src

     this process is called *reconciliation* in react and is *triggered every time =setState= or
     =ReactDOM.render= are called*.

     we can nearly answer our original question. in most react code, you don't actually call to
     =React.createElement=, you use JSX instead. the abstraction layer between JSX and react is that
     /JSX is always going to get compiled to React.createElement invocations/, often via Babel.

     rewriting our code using proper JSX:
     #+begin_src js
       function Button ({ addFriend }) {
         return (
           <button onClick={addFriend}>Add Friend</button>
         )
       }

       function User ({ name, addFriend }) {
         return (
           <div>
             <p>{name}</p>
             <Button addFriend={addFriend}/>
           </div>
         )
       }
     #+end_src

     this code becomes, after transformation, our /original code!/
     #+begin_src js
       function Button ({ addFriend }) {
         return React.createElement(
           "button",
           { onClick: addFriend },
           "Add Friend"
         )
       }

       function User({ name, addFriend }) {
         return React.createElement(
           "div",
           null,
           React.createElement(
             "p",
             null,
             name
           ),
           React.createElement(Button, { addFriend })
         )
       }
     #+end_src


     so what do we call actions like calling to a react component, =<Icon />=? We call it *"creating
     an element"* because after JSX is compiled, that is what we actually get:
     #+begin_src js
       React.createElement(Icon, null)
     #+end_src

     *all of these are examples of "creating a react element"*:
     #+begin_src js
       React.createElement(
         'div',
         { className: 'container' },
         'Hello!'
       )

       <div className='container'>Hello!</div>

       <Hello />
     #+end_src
*** JSX for beginners
**** variables

     whenever you want to use an expression, i.e. something yielding a value, wrap it in ={}='s:
     #+begin_src js
       return (<p> hi {name}</p>)
     #+end_src

**** rendering nothing     

     if you want react to *render nothing*, simply return =null=:
     #+begin_src js
       render() {
         if (isLoading() === true) {
           return null
         }

         return (
           ...
         )
       }
     #+end_src

**** conditional rendering
     
     because JSX is "just js", there is no fancy templating syntax or structures built-in to use
     like with jinja or vue.js. you just use js conditionals.
     #+begin_src js
       render() {
         const authed = isAuthed()

         if (authed === true) {
           return <h1>Welcome back!</h1>
         } else {
           return <h1>Login to see your dashboard</h1>
         }
       }
     #+end_src

***** ternary operator
      
      when there is only one condition, common to use js' *ternary operator*:
      #+begin_src js
        render() {
          return isAuthed() === true
            ? <h1>Welcome back!</h1>
            : <h1>Login to see your dashboard</h1>
        }
      #+end_src

      we can go one step further, rendering the ternary logic inside of ={}='s:
      #+begin_src js
        render() {
        // this is kind of whack imho
          return (
            <div>
              <Logo />
              {isAuthed() === true
                ? <h1>Welcome back!</h1>
                : <h1>Login to see your dashboard</h1>}
            </div>
          )
        }
      #+end_src

      finally, it is common to use the =null= to yield nothing pattern with ternary-style components:
      #+begin_src js
        render() {
          return (
            <div>
              <Logo />
              {showWarning() === true
                ? <Warning />
                : null}
            </div>
          )
        }
      #+end_src

**** logical =&&= operator

     =&&= is the logical AND operator:
     #+begin_src js
       if (user && authed) { // ...
     #+end_src

     it also *short-circuits*, i.e. won't bother checking the second operand when it knows the first
     is false. consequentially, we can use it as a /terser ternary operator/:
     #+begin_src js
       render() {
         return (
           <div>
             <Logo />
             {showWarning() === true && <Warning />}
           </div>
         )
       }
     #+end_src

**** react fragment

     what is wrong with the following react code?
     #+begin_src js
       render() {
         const name = 'Tyler'

         return (
           <h1>Hello, {name}</h1>
           <p>Today is {getDay()}</p>
           <p>What is 2 + 2? {2 + 2}</p>
         )
       }
     #+end_src

     while it looks good, the problem is that *adjacent JSX elements must be wrapped in an enclosing
     tag*, i.e. *we can only ever return one top-level element from a component*. in the above snippet
     we are trying to return three, however, and can fix this by wrapping them all in a =div=:
     #+begin_src js
       render() {
         const name = 'Tyler'

         return (
             <div>
               <h1>Hello, {name}</h1>
               <p>Today is {getDay()}</p>
               <p>What is 2 + 2? {2 + 2}</p>
             </div>
         )
       }
     #+end_src

     however, now we have a new problem, though lesser in nature: we are unnecessarily introducing
     an extra div, a semantically useless one. this is what =React.Fragment= was intended for. When
     you want to return adjacent elements but don't want to change the markup, use =React.Fragment=
     #+begin_src js
       render() {
         const name = 'Tyler'

         return (
           <React.Fragment>
             <h1>Hello, {name}</h1>
             <p>Today is {getDay()}</p>
             <p>What is 2 + 2? {2 + 2}</p>
           </React.Fragment>
         )
       }
     #+end_src

     there is a shortcut for this, but some people don't like it i guess?
     #+begin_src js
       render() {
         const name = 'Tyler'

         return (
           <>
             <h1>Hello, {name}</h1>
             <p>Today is {getDay()}</p>
             <p>What is 2 + 2? {2 + 2}</p>
           </>
         )
       }     
     #+end_src

**** capitalization and react components

     how does react tell the difference between plain HTML and components? *capitalization*. that's all.

** passing data to components

*** intro to props

    react relies heavily on composition and, as such, there needs to be a way to pass data /into/
    components. this requires covering the topic of *react props*, which are to components what
    arguments are to functions.

    there are two facets to this:
    1. how to pass data into components
    2. accessing the data once it has been passed in

**** passing data to a component

     this is straightforward, you pass data to a react component the same way you would set an HTML
     attribute:
     #+begin_src js
       <Hello name='elias' />
     #+end_src
     for this snippet, we are passing in a =name= prop to the =Hello= component.

**** accessing props
     in a *class component*, accessing a prop passed to it is easy via the =props= key on the component's
     instance, i.e. =this=:
     #+begin_src js
       class Hello extends React.Component {
         render() {
           return (
               <h1>hello, {this.props.name}</h1>
           )
         }
       }
     #+end_src

     each prop that is passe to a component is added as a key on =this.props=. if no props are passed
     to a component, =this.props= will be an empty object.

     *we can pass almost anything as a prop to a component*
     #+begin_src js
       <Profile 
         username='elias'
         authed={true}
         logout={() => handleLogout()}
         header={<h1>👋</h1>}
       />
     #+end_src

     *if you pass a prop without a value, its value will be set to =true=*
     #+begin_src js
       // these are equivalent
       <Profile authed={true} />

       <Profile authed />
     #+end_src

*** props practice

    make each problem's practice code yield the same UI given:
    [[file:assets/2933430.jpg]]

**** problem 1

     #+begin_src html :tangle "./practice/props/problem1/index.html"
       <div id='app'></div>
     #+end_src

     #+begin_src js :tangle "./practice/props/problem1/index.js"
       class Badge extends React.Component {
         render() {
           return (
             <>
               <img src={this.props.img} />
               <h1>Name: {this.props.name}</h1>
               <h3>username: {this.props.username}</h3>
             </>
           )
         }
       }

       ReactDOM.render(
         <Badge 
           name='Tyler McGinnis'
           username='tylermcginnis'
           img='https://avatars0.githubusercontent.com/u/2933430?v=3&s=460'/>,
         document.getElementById('app')
       );
     #+end_src

**** problem 2

     #+begin_src html :tangle "./practice/props/problem2/index.html"
       <div id='app'></div>
     #+end_src

     #+begin_src js :tangle "./practice/props/problem2/index.js"
       var USER_DATA = {
         name: 'Tyler McGinnis',
         img: 'https://avatars0.githubusercontent.com/u/2933430?v=3&s=460',
         username: 'tylermcginnis'
       }

       class Badge extends React.Component {
         render() {
           return (
             <div>
               <img src={this.props.user.img} />
               <h1>Name: {this.props.user.name}</h1>
               <h3>username: {this.props.user.username}</h3>
             </div>
           )
         }
       }

       ReactDOM.render(
         <Badge user={USER_DATA}/>,
         document.getElementById('app')
       );
     #+end_src

**** problem 3

     #+begin_src html :tangle "./practice/props/problem3/index.html"
       <div id='app'></div>
     #+end_src

     #+begin_src js :tangle "./practice/props/problem3/index.js"
       class Avatar extends React.Component {
         render() {
           return (
             <img src={ this.props.img } />
           )
         }
       }

       class Label extends React.Component {
         render() {
           return (
               <h1>Name: { this.props.name }</h1>
           )
         }
       }

       class ScreenName extends React.Component {
         render() {
           return (
               <h3>Username: { this.props.username }</h3>
           )
         }
       }

       class Badge extends React.Component {
         render() {
           return (
             <div>
               <Avatar img={ this.props.user.img }/>
               <Label name={ this.props.user.name }/>
               <ScreenName username={ this.props.user.username }/>
             </div>
           )
         }
       }

       ReactDOM.render(
         <Badge user={{
           name: 'Tyler McGinnis',
           img: 'https://avatars0.githubusercontent.com/u/2933430?v=3&s=460',
           username: 'tylermcginnis'
         }} />,
         document.getElementById('app')
       );
     #+end_src

** rendering lists

*** lists in react
